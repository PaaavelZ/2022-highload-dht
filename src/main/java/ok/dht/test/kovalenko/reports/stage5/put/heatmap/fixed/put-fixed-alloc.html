<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BP~a@Ap@fA{B~BwF`HmKrLyWs[g\k]c^g^t^afB??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????@@??????G?@?????????????G???@@???@??????G?????????@?G??G?G?G???G???G??@?????G?@??@??G????@??@???????@?O@????G?????H??GG?@@??????????????G??????G@?G?O??@??HG@?@??GH?????@@??G?@?O?G???????O@?O?G????@??A??G????G??G??G??????H@@@@???????G?@??G?????O?A??@A???????O?GGO?G??G@?HG??G??@?@?GH@IG???OG?OH?H??I@?G@??????@???G???@?G?X??@GGO????H??G?@?G@?G?G@?@??G@@X@?????@HH??G?@OOGG?O?????A?I@?@G????@GH?G?A?AG???O???IG@???@H@@A?GG?P????G?G?G?`HG??????H?IAO@H?GG???@?GO@?O@?GG???I?@?G@H???H@IG??@G??@G?????@@????P??GA@@?A????HGA?G@?G@@H@G??@@G??IA@?????@?GGA??G?@?@@G??@?@????HO??@@??G?@@A?HOG?HH?@????I@?@G?@??????@G@G?G?HG??G?G?H@?@?O?A@????HG?JG?GHGI????H?@A@?A?@@?@@@GG?@?H@???@@G?@?GG??GO@?G@???H??GP????A@O?G?H?G@@HA@@???@GGXG?@?@I@?GG??@`?G??????@@G?G??GHO@?@@??OGHO?O?G??????G@@G??H??GA?G?@H?@????GA@GG???@GG???I??@?G@@O?G?A@??GGG?G@???HAOH@??????????A@@?QGG??@@?@I?@?HI?@@????@HAG@WGG??H???@??PGG@?GG???A?@?@A@GP?G??GG???O???????A??????G@????????@G?@G@?@?A?GG?@?@?X??HH???B?A@G?@?GG???GO?GG???@?G?@G@@?GA?I?G??A@?@????I?G??PHG?@@GP?HH??HG??@??OBA@?G?G???@??GGO?G?P@??@?@?????@H?CG@???O?G??II@?@GH?@@?@@??@H??@GH??????GH??G?@???@??G??A???HO??@?I??@@?@J@A?@@@?GH???G??AH???@H?@@A?@?@H??????@?G?@??????G?G???@O????G???????G?O?????HGG?G?@@?@@B@O???GHG@G@?H@??G??A?I@?G??@?O@GH??H?A???????@?@HG?@G??GGG??@?O???????@HGOP???I@OB?@G?GGGGG???G??A@???HG??O????G???GG???G@G???G@@X@????HO?GG@GO@?@OHG?@?GG??@???@HG?????@G??GH?GO?A?????????????G@?????@@GO?IG????@????@?G@?@OGO?G?G@????@H@??G?AA??G?AG?@????@QG@O@@G?GhvAhvAwwAlzA_~Ak_BebBwcBfvCqaBpdBsqBn{AphBheBooBnoClgBhmBsmBg{BaiBdiB`kBmnBcoBa_CmhCekC}~AkdBiqBexBlyBx_CncBoiB|jBvlB~pBjwBcyB{zBu{Bv{BrfC{lCyqCg{A|~AifBxfBgmBknBvnB}nBzrBdsBrvBrwBwwBdyBu|Bm~B}~BwaClbC|jCzoCiyA`zAl{Ax{A_|As~AxcB_gBrgB`jBikB}pB|qBbrBjrBmvBywBhyBryBvzBd{Bi_CjbCobCbcCwfCwgCdhCphCzhClqCpvAoxAzxA~yAazAv{Ab|Ag|Ay|Aw~AkaBwaBybB`cBdfByhBwiBcjBkjBnnBkpBnpBgqBjsBmsBntBstBytBcwBgwBowBpwBfyBvyBzyBa{Bq{B~{B||B__CgaCjaCpaCvaCicC|cC}cC|dCveClgCahCfiCxjCzjCkkCblCvlCgmCwnCspCdrCerCltCqyCz{Cg~Cn~Cl_DuvAyvAsxAwxAxxAyxA_yApyAuyAfzAvzAf{Ah{Ai{Aj{Aq{A{{A}{A`|Ac|Ah|Au|Aw|A`}Af}Am}Az}A}}Ad~An~At~Ay~A`_Bh_Bi_Bz_Ba`Bb`Bd`Bf`Bu`B}`B_aBlaBtaBbbBdbBmbBnbBobBgcBicBkcB|dBfeBleBueB~eBffBlfBufBagBfgBvgBxgB{gBbhBjhBuhB|hBciBjiBniBxiBziBrjBvjBjkBnkB~kBglBllBqlBrlBwlBmmBnmBpmBymBenBunB~nBapBcpBlpBdqBtqBzqBqrBksBktBbuBhuBiuBjuBluBouB~uBavBuvB|vBdwB}wB_xBnxBqxBbyBmyBqzBxzB`{Bs{Bc|Bg|Bh~Bd_C}_C~_Cd`Cg`C`aCeaC_bCwbClcC{cCddCedC}dCheC{eC_fCkfClfCzfCxgCzgCjhCkhCyhCijCojCnkCokCqkCwkC_lCemCkmCmmCnnCcoCgoCbpCkpCppCupCbsCrsCktCutC{tCpuCtuCzuC{uC`vCmvCdwCswChxC~xC|zCh|Cq|Ca}Cw}Ch~CuaDodDsdDzfDfgDfhDriDivAkvAlvAmvAnvAovAqvArvAsvAtvAvvAwvAxvAzvA|vAowAxwAzwA{wA|wA}wA~wAnxAqxArxAvxA{xA|xA}xA~xAkyAlyAmyAnyAoyAqyAryAsyAtyAvyAwyAxyAzyA{yA|yA}yA_zAbzAczAdzAezAhzAjzAkzAmzAozApzAqzArzAszAtzAuzAxzAyzAzzA|zA~zA`{Aa{Ac{Ad{Ae{Am{Ao{As{At{Au{Aw{Ay{Az{A|{A~{Aa|Af|Ai|Aj|Ak|Al|Am|An|Ao|Ap|Aq|Ar|As|At|Av|Ax|Az|A{|A}|A_}Aa}Ab}Ac}Ad}Ag}Ah}Aj}Ao}Aq}Ar}As}At}Au}Av}Aw}Ax}Ay}A|}A~}A`~Ab~Ac~Af~Ag~Ah~Aj~Ak~Al~Am~Ao~Ap~Aq~Ar~Au~Av~Ax~Az~A{~A__Ba_Bb_Bd_Be_Bf_Bg_Bm_Bo_Bp_Bq_Br_Bs_Bv_Bw_By_B|_B}_B~_B_`B``Be`Bg`Bh`Bi`Bj`Bk`Bl`Bm`Bn`Bo`Bp`Bq`Br`Bs`Bt`Bv`Bx`By`Bz`B{`B|`B~`BaaBcaBdaBeaBfaBgaBiaBnaBoaBpaBraBuaByaB{aB|aB}aB~aB_bB`bBabBfbBhbBibBjbBkbBlbBqbBsbBubBvbBwbBxbB{bB|bB}bB~bB_cBacBbcBccBdcBecBfcBhcBjcBocBscBtcBucBvcBzcB{cB|cB_dBbdBedBfdBhdBjdBldBsdBtdBudBwdB{dB}dB_eB`eBaeBceBdeBgeBieBkeBmeBneBpeBreBseBteBveBweBxeByeB|eB`fBafBbfBcfBefBgfBhfBkfBmfBnfBpfBqfBrfBsfBvfBwfByfB{fB|fB`gBbgBcgBegBigBjgBkgBmgBogBpgBqgBsgBygBzgB|gB~gB`hBahBchBdhBehBfhBhhBkhBlhBmhBnhBohBqhBxhB{hB}hB~hB_iBeiBgiBmiBqiBriBtiBuiBviByiB{iB|iB}iB~iB_jBajBdjBfjBijBjjBnjBojBpjBsjBtjBujBwjBxjByjBzjB_kBakBckBgkBhkBlkBmkBokBskBtkBukBxkBykBzkBblBclBelBflBhlBilBjlBmlBolBplBslBtlBulBzlB{lB|lB}lB~lB_mB`mBamBbmBcmBemBfmBjmBkmBlmBomBqmBrmBtmBumBvmBwmBxmB|mB~mB_nB`nBanBbnBdnBfnBgnBhnBinBlnBpnBqnBrnBsnBtnBxnBynB{nB|nB`oBboBeoBfoBhoBioBjoBkoBmoBnoBqoBroBsoBtoBuoBvoBxoByoB|oB~oB_pB`pBbpBdpBepBfpBgpBhpBjpBmpBopBqpBrpBtpBupBxpBypB{pB|pB`qBaqBbqBcqBfqBhqBkqBlqBmqBnqBpqBqqBrqBuqBvqBwqBxqByqB{qB`rBarBcrBerBfrBgrBlrBmrBsrBtrBvrBxrByrB|rB}rB_sB`sBasBbsBcsBgsBhsBisBlsBnsBpsBrsBssBtsBusBvsBxsBysBzsB|sB}sB_tB`tBatBbtBdtBgtBhtBitBjtBotBptBqtBrtButBvtBwtB|tB~tBcuBeuBfuBguBnuBquBsuBtuBuuBxuByuB|uB}uB_vB`vBbvBcvBdvBevBgvBhvBivBjvBkvBlvBpvBqvBsvBxvByvB~vB_wBawBbwBewBfwBhwBkwBmwBnwBtwBuwBvwBxwBzwB{wB|wB~wBaxBcxBdxBgxBhxBjxBkxBlxBmxBpxBsxBtxBvxBzxB|xB~xB`yBayBgyBjyBkyBoyBpyBqyBsyBtyBuyByyB{yB}yB~yB`zBbzBdzBezBfzBgzBhzBjzBmzBpzBszBtzBuzByzB}zB~zBc{Bf{Bi{Bj{Bk{Bm{Bo{Bp{Bw{Bx{By{B{{B|{B}{Ba|Bb|Bd|Bf|Bl|Bm|Bn|Bq|Bs|Bw|Bx|By|Bz|B{|B}|B_}B`}Ba}Bd}Bf}Bh}Bi}Bk}Bo}Bp}Br}Bt}Bv}Bw}Bx}By}Bz}B{}B|}B}}B_~Ba~Bg~Bi~Bk~Bl~Bn~Bq~Bs~Bt~Bv~By~Bz~B|~B`_Cb_Ce_Cf_Ch_Cl_Cm_Cn_Co_Cp_Cq_Ct_Cu_Cv_Cw_C{_C_`C``Ca`Cb`Ck`Cl`Cr`Cs`Cu`Cv`Cx`Cz`C|`C~`CbaCdaCfaCiaCkaCmaCnaCqaCsaCtaCuaCyaCzaC{aC}aC~aCabCcbCdbCebCgbChbCibCkbCmbCpbCrbCsbCubCvbCybC{bC}bC~bC_cC`cCacCccCgcChcCncCpcCqcCrcCtcCvcCwcCycCadCcdCgdChdCidCmdCodCpdCrdCsdCtdCvdCxdCydCzdC{dC_eCaeCbeCdeCeeCgeCieCleCyeCzeC}eC~eCbfCdfCefCffCgfCifCofCqfCtfCvfCxfC|fC}fC~fC_gCagCcgCegCfgCggChgCjgCkgCmgCogCsgCugCvgC|gC~gC`hCbhCehCfhCghChhClhCrhCthCvhCwhCxhC}hC_iC`iCaiCbiCciCdiCeiCgiChiCiiCkiCoiCriCsiC}iC~iC_jC`jCbjCcjChjCljCmjCnjCpjCqjCsjCvjCyjC}jC~jC_kC`kCdkCfkChkCikCjkCpkCskCtkCukCxkCykC{kC|kC}kCalCflChlCklCllCqlCrlCxlC|lC}lCamCbmCdmChmCjmClmCnmComCpmCsmCumCwmCxmCymC{mC_nCbnCcnCdnCfnChnCinCjnClnConCqnCrnCunCvnCynCznC{nC}nC_oC`oCaoCdoCfoCioCkoCloCooCroCtoCwoC{oC|oC}oC~oC_pCapCcpCdpCepCfpCjpClpCmpCrpCvpCxpCypC}pC~pCbqCcqCeqCfqCgqChqCoqCqqCrqCwqCzqC~qC_rC`rCarCbrCcrCgrCirCorCprCrrCvrC~rC_sCasCdsCfsCisCjsClsCmsCnsCosCpsCqsCtsCusCvsCxsC|sC~sCctCdtCftChtCjtCmtCotCptCqtCvtCwtCxtCztC~tC`uCbuCduCfuChuCiuCjuCkuCnuCsuCvuCwuCxuCyuC}uCbvCcvCevCgvClvCnvCqvCsvCtvCvvCxvCyvC|vC~vC_wC`wCbwCgwCiwCvwCywC|wC~wCcxCexCgxCixClxCoxCsxCvxCwxC}xCdyCeyCfyCgyCkyCoyCtyCvyCxyCyyC_zC`zCazCbzCezCfzChzCkzCnzCtzCvzCxzCzzC{zC~zC_{Cg{Cj{Cl{Cq{Cs{Ct{Cx{C}{C`|Cc|Ce|Cg|Cl|Cn|Cp|Cv|Cx|Cy|Cz|C~|C_}Ch}Ci}Cm}Cp}Cq}Cr}Cy}C{}C}}C_~Ca~Cf~Co~Cp~Cq~Cr~Ct~Cu~Cw~C}~C~~C`_Da_Db_Dc_Dd_De_Df_Dg_Dj_Dn_Dv_Dw_D{_D}_D``Dg`Dh`Di`Dj`Dq`Dt`Dy`D{`DaaDcaDdaDfaDiaDkaDlaDoaDpaDqaDtaDvaD}aD_bDabDbbDobDqbDsbD}bD~bD_cDccDecDgcDmcDqcDucDxcD|cD~cD`dDbdDcdDfdDqdDudDxdDydD|dDbeDfeDieDjeDkeDleDmeDneDueDxeDyeD}eDcfDdfDhfD}fD~fD`gDbgDdgDpgDrgDsgD`hDahDbhDchDdhDnhDuhDvhDxhD|hDgiDiiDtjDujDgkDqkDslD}lDjvA{vA}vA~vA_wA`wAawAbwAcwAdwAewAfwAgwAhwAiwAjwAkwAlwAmwAnwApwAqwArwAswAtwAuwAvwAywA_xA`xAaxAbxAcxAdxAexAfxAgxAhxAixAjxAkxAlxAmxApxAtxAuxA`yAayAbyAcyAdyAeyAfyAgyAhyAjyAyyAgzAizAnzAwzA{zA}zA_{Ab{Ak{Ap{Ar{Ad|Ae|A||A~|Ae}Ai}Ak}Al}An}Ap}A{}Aa~Ae~Ai~A~~Ac_Bj_Bl_Bn_Bt_Bu_Bx_B{_Bc`Bw`B`aBbaBhaBjaBmaBsaBvaBxaBzaBcbBgbBpbBrbBtbBzbBlcBmcBpcBqcBrcBycB}cB~cB`dBadBcdBddBgdBidBmdBndBodBqdBrdBvdBxdBydBzdB~dBbeBeeBjeBoeBqeBzeB{eB}eB_fBjfBofBtfBzfB}fB~fBdgBggBhgBngBtgBugBwgB}gB_hBghBihBrhBshBthBvhBwhBzhB`iBbiBfiBhiBiiBkiBliBpiBsiBbjBejBgjBhjBljBmjBqjB{jB}jB~jBbkBdkBekBfkBkkBpkBqkBrkBvkBwkB{kB|kB}kB_lB`lBalBdlBklBnlBxlBylBdmBimBzmB{mB}mBcnBjnBonBwnBznB_oBaoBdoBgoBloBpoBwoBzoB{oB}oBipBppBspBvpBwpBzpB_qBeqBjqBoqB}qB~qB_rBdrBhrBirBkrBnrBorBprBrrBurBwrB{rB~rBesBfsBosBqsBwsB{sB~sBctBetBftBltBmtBttBxtBztB{tB}tB_uB`uBauBduBkuBmuBpuBruBvuBwuBzuB{uBfvBnvBovBtvBvvBwvBzvB{vB}vB`wBiwBlwBqwBswB`xBbxBfxBixBoxBrxBuxBwxBxxByxB{xB}xB_yBeyBiyBnyBwyBxyB|yB_zBazBczBizBkzBlzBnzBozBrzBwzBzzB|zB_{Bb{Be{Bh{Bl{Bn{Br{Bt{Bz{B_|B`|Be|Bh|Bi|Bj|Bk|Bo|Bp|Br|Bt|Bv|B~|Bb}Bc}Be}Bg}Bj}Bl}Bm}Bn}Bq}Bs}Bu}B~}B`~Bb~Bc~Bd~Be~Bf~Bj~Bo~Bp~Br~Bu~Bw~Bx~B{~B~~Bc_Cg_Cj_Ck_Cr_Cs_Cy_Cz_C|_Cc`Ce`Cf`Ch`Ci`Cj`Cm`Cn`Co`Cp`Cq`Ct`Cw`Cy`C{`C}`C_aCaaCcaChaClaCoaCraCxaC|aC`bCbbCfbCnbCqbCtbCxbCzbC|bCdcCecCfcCjcCkcCmcCocCscCucCxcCzcC~cC_dC`dCbdCfdCjdCkdCldCndCqdCudCwdC~dC`eCceCfeCjeCkeCmeCneCoeCpeCqeCreCseCteCueCweCxeC|eC`fCafCcfChfCjfCmfCnfCpfCsfCufCyfC{fC`gCbgCdgCigCngCpgCqgCrgCtgCygC{gC}gC_hCchCihCnhCohCqhCshCuhC{hC|hC~hCjiCliCmiCniCpiCqiCtiCuiCviCwiCxiCyiCziC{iC|iCajCdjCejCfjCgjCjjCkjCrjCtjCujCwjC{jCakCbkCckCgkClkCmkCrkCvkCzkC~kC`lCclCdlCelCglCilCjlCmlCnlColCplCslCtlCulCwlCylCzlC~lC_mC`mCcmCfmCimCqmCrmCtmCvmCzmC|mC}mC~mC`nCanCenCgnCknCmnCpnCsnCtnCxnC|nC~nCboCeoChoCjoCmoCpoCqoCsoCuoCvoCxoCyoC`pCgpChpCipCnpCopCqpCtpCwpCzpC{pC|pC_qC`qCaqCdqCiqCjqCkqCmqCnqCpqCsqCtqCuqCvqCxqC{qC|qC}qCfrChrCjrCkrClrCmrCnrCqrCsrCtrCurCwrCxrCyrCzrC{rC|rC}rC`sCcsCesCgsChsCksCssCwsCysCzsC{sC}sC_tC`tCatCbtCetCgtCitCntCrtCstCttCytC|tC}tC_uCauCcuCeuCguCluCmuCouCquCruCuuC|uC~uC_vCavCdvChvCivCjvCkvCovCpvCrvCuvCwvCzvC{vC}vCawCcwCewCfwChwCjwCkwClwCmwCnwCowCpwCqwCrwCtwCuwCwwCxwCzwC{wC}wC_xC`xCaxCbxCdxCfxCjxCkxCmxCnxCpxCqxCrxCtxCuxCxxCyxCzxC{xC|xC_yC`yCayCbyCcyChyCiyCjyClyCmyCnyCpyCryCsyCuyCwyCzyC{yC|yC}yC~yCczCdzCgzCizCjzClzCmzCozCpzCqzCrzCszCuzCwzCyzC}zC`{Ca{Cb{Cc{Cd{Ce{Cf{Ch{Ci{Ck{Cm{Cn{Co{Cp{Cr{Cu{Cv{Cw{Cy{C{{C|{C~{C_|Ca|Cb|Cd|Cf|Ci|Cj|Ck|Cm|Co|Cr|Cs|Ct|Cu|Cw|C{|C||C}|C`}Cb}Cc}Cd}Ce}Cf}Cg}Cj}Ck}Cl}Cn}Co}Cs}Ct}Cu}Cv}Cx}Cz}C|}C~}C`~Cb~Cc~Cd~Ce~Ci~Cj~Ck~Cl~Cm~Cs~Cv~Cx~Cy~Cz~C{~C|~C__Dh_Di_Dk_Dm_Do_Dp_Dq_Dr_Ds_Dt_Du_Dx_Dy_Dz_D|_D~_D_`Da`Db`Dc`Dd`De`Df`Dk`Dl`Dm`Dn`Do`Dp`Dr`Ds`Du`Dv`Dw`Dx`Dz`D|`D}`D~`D_aD`aDbaDeaDgaDhaDjaDmaDnaDraDsaDwaDxaDyaDzaD{aD|aD~aD`bDcbDdbDebDfbDgbDhbDibDjbDkbDlbDmbDnbDpbDrbDtbDubDvbDwbDxbDybDzbD{bD|bD`cDacDbcDdcDfcDhcDicDjcDkcDlcDncDocDpcDrcDscDtcDvcDwcDycDzcD{cD}cD_dDadDddDedDgdDhdDidDjdDkdDldDmdDndDpdDrdDtdDvdDwdDzdD{dD}dD~dD_eD`eDaeDceDdeDeeDgeDheDoeDpeDqeDreDseDteDveDweDzeD{eD|eD~eD_fD`fDafDbfDefDffDgfDifDjfDkfDlfDmfDnfDofDpfDqfDrfDsfDtfDufDvfDwfDxfDyfD{fD|fD_gDagDcgDegDggDhgDigDjgDkgDlgDmgDngDogDqgDtgDugDvgDwgDxgDygDzgD{gD|gD}gD~gD_hDehDghDhhDihDjhDkhDlhDmhDohDphDqhDrhDshDthDwhDyhDzhD{hD}hD~hD_iD`iDaiDbiDciDdiDeiDfiDhiDjiDkiDliDmiDniDoiDpiDqiDsiDtiDuiDviDwiDxiDyiDziD{iD|iD}iD~iD_jD`jDajDbjDcjDdjDejDfjDgjDhjDijDjjDkjDljDmjDnjDojDpjDqjDrjDsjDvjDwjDxjDyjDzjD{jD|jD}jD~jD_kD`kDakDbkDckDdkDekDfkDhkDikDjkDkkDlkDmkDnkDokDpkDrkDskDtkDukDvkDwkDxkDykDzkD{kD|kD}kD~kD_lD`lDalDblDclDdlDelDflDglDhlDilDjlDklDllDmlDnlDolDplDqlDrlDtlDulDvlDwlDxlDylDzlD{lD|lD~lD_mD`mDamDbmDcmDdmDemDfmDgmDhmDimDjmDkmDlmDmmDnmDomDpmDe]??????eB????A?A?@????@?????@???@????G??HD@?B???@?@?????B??kAB@ElL?K?@sB????B???lAB?????Aa@q@???@G???kAE?u@lB????Dr@u@?@?KgF@?DQQO?G???o@O?H???}Q??????wX??OE`Cx@_CHED?E@L??@??@`C???qGA?????@?q@nA?r]T???pYiB\?????s@??A?B}]?TBvB???r@?pA??Qi@@KlAE????ObC?\Vs@?????mA??@r@?_@s@~_@O@y]?A???sBg@????q[As@?dCK????z@??O??s@???DOAGr@?B??i@???kAB`A??@Gf@???d@?kCq@zBd@V?@iCLHnFB?EAbCf@O?lH???lb@BG{c@z@gc@@g@@?EV?wBq@?T??z@??QtH`AbOg@G?H???BoW?@??sBBL??eT??|A_@zAzAT???@??bC?x\vB??HZD\qGG??o@L?tC?{CB?EZeHaH?lB?@KyA??vCoCA?vCqH\uAxCN?tC??bG??ZU?cf@iC`AeI@?iB?qC?BVe[f@HAf@i@zBkAr@?pA?{Euf@??lg@ZkC??wBlI?{H_CbI@X???b_@@Kf@dCpAuUti@Dd@dC~CU??NVDkGhCi@lA?vCFX?A??F?F?@nF??AA?aA~GnA@uA?bA???_K???D??@\??kGxBX?x@a@H}A?@y_@E_@A?nEd@?}A??eBlCN??OyAsC?F???o@a@?nH?pb@?`GFaINm@?aA@XfIae@bGg@qCz@d@{A?D?KsCN?lB?tH?QG??uAZ?Uo@?aA?D{HNg@Ux@?l@TvB{Cl@?????wa@uAp`@hC`D?aI@_C`GdD~I??XA}k@uCwFZ?Hm@cDkl@Uok@FFL?~I?em@EBm@m@tIaKDjk@u@V@uC@}G@a@@?H?cD{AqIke@?NKzA_@wF?|[LQeH{j@qh@lA?|l@E?F?~l@N`Agk@??ZQq@|m@aH?aA??i@a@qH??bm@G?u@?GKzA{^F?}i@bA?qf@_@{EVbAf@yAXtI??dDnH??dD?{AxC?Dxj@?QbA~C@_@?xCl@~CkC`HNeBlH??qIz@?o@l@BtCAAL}@xBeI`HnAiBZX?fG?}GlCab@dJ?F{C}AoCsC??_o@i@`D????D@?EHL?uC?L\|A?nA@nEF}@m@~o@lIFLg@bI|AUDgd@`^TNgJa@??bAlCpA@?@vj@eZTdp@x@?H?}m@?\up@?V}@?@?BdJm@oi@?qo@UzBg\bo@bh@??Ucl@AgFB?mAX}AmAu@aAl@d@?oj@F}@gJv_@?oCxBGfh@???KfG`C`DiC_@Er`@hC?}@?`AmA???x@`l@?wBqCl@li@K??cD~G?bb@fIAmp@|AT{AyA@?Q?A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?\?]?^?_@?`@?a@?b@?c@?d@?e@?f@?g@?h@?i@?j@?k@?l@?m@?n@?o@?p@?q@?r@?s@?t@?u@?v@?w@?x@?y@?z@?{@?|@?}@?~@?_AxJh@?`A?aA?bA?cA?dA?eA?fA?gA?hA?iAiJBjJjA?kA?lA?mA?nA?oA?pA?qA?rA?sA?tA?uA?vA?wA?xA?yA?zA?{A?|A?}A?~AhDCkJEmJGbBIpJKrJMsJOuJQ?_B?`B?aB?bB?cB?dB?eB?fB?gB?hB?iB?jB?kB?lBcAmB?nB?oB?pB?qB?rB?sB?tB?uB?vB?wB?xB?yB?zBcADlJFnJHoJJqJLfDNtJPgD_BmKaBoKcBpKeBrKgBsKiBuKkB?{B?|B?}B?~B?_C?`CcAaC?bC?cC?dC?eC?fC?gC?jAiDnA?hC?iC?jC?kC?lC?mC?nCwKnBfBpByKrB{KtB?oC?pC?qC?rC?sC?tC?uC?vC?wC?xC?yC?zC?{C?|C?}C?~C?_D?`D?aDcAjAsDoA?bD?cD?dD?eD?fD?gDdAhD?iDn@jD?kD?lDdAoB?mD?nD?oD?pD?qDn@rD?sD?tD?uD?vD?wD?xD?yD?zDmLbCnLdCpLfCn@jAsDhC?{DeAkCJmC?|DuDoBxKqBzKsBoDuB|K}DgB~DpMzDzDmAjDoA~LcD`MeD?_E?`E?aE?bE?cE?dE?eE?fEzMnAkDbD_MdDaM_E_NaE?gEaEhE?iE_EpBsLsBoDoCgBqCfAsCxLuCyLwCzLyCxD{ChB}C?jE?kE?lE?mE?nE?oE?pE?qE?rE?sE?tEgNqBvMtBuLpCvLrCwLtCvDvCwDuE?vE?wE?xE?yErDmA{MpA?zEuMlCrL{E_LEgKHaLKjKNdLQlK`BnKbBnDdB?|E?}ErMcCoLeCqDgCgEnAtD~E?_Fn@mBdA`FfAaF?bFvDcF?dF?eF?fF?gF?hF?iF?jF?kF?lF?mFzNyEgEnF?oF?pF?qF?rF?sF?tF?uF?vF?wF?xF?yF?zF?{F?|F?}FhMnB?~F?_G?`G?aG?bGbBcG?dG?eG?fG?gG?hG[iGgBjG?kGbNoA|MdDdNlG?mGhAnG?oG[rBtLoCiNrCvNuCcEpGCmC?qGcOdC~DgCiEhC?~EeOgC?mBgOrC?aFiOuC?cF?rGgAsGyMzBlPeCdOjAtM~EoPmBqPaFsPcFkEtG?uG?vG?wG?xG?yG?zGjPsBhNpCfEsCkNvCwDxCgAzC{L|C?{G?|G?}G?~G?_H?`H?aH?bH?cH?dH?eH?fH?gHpOjA?hH?iH?jH?kH?lH?mH?nHqEbDcNeD~M`E`EoH?pH?qH?rH?sH?tH{PtBuNqCjNtCwNwClNzCnB}C?uH?vH?wH?xHmQcD}M_EbEgEeNiEiAoCrEsC}PwC?yHgAzH?{HyJq@zJ|H?}H?~HwQo@[_I?`I?aI?bI|NF`LIiKLfDcI?dI?eI?fI?gIvQdDgPmGhAhI?iIxQpC|PtCsQxC_Q{ChBjI?kI?hEfNo@qElI?mI?nI?oI?pI?qImBrI~QGhKJbLMkKPgDR?sI?tI?uI?vI?wI?xI?yI?zI?{IaReDbMgDdMiDfMkDoEoBiMnDjMpDkMgC?rD?|I}DxD_F_EbE}I?~I?_JgRiElRH}NLcLOmD_BfLbBnD`J?aJ?bJ?cJ?dJ?eJdRqCrQuCcExCfR|C?fJ?gJ?hJ?iJ?jJ?kJeSrCkPvC~PyCmN|CyD~C?lJ?mJ?nJ?oJcQo@hDpJ?qJ?rJ?sJ?tJ?uJjSsCyQuExNwExEmAhEvJ?wJ?xJ?yJ?zJ~RI_RMnRQvJsI?{JjA|J?}J?~J?_K?`KtPfCsMmAjDhCnP_FfOnB?`FhObFjEaK?bKtEyDqMzBsStCeRyCdFcK?dKvSJmRN?eK?fKiAuBwMpCfEgK?hK?iK?jK?kK?lKp@`E`E}I|R_JaNfE?mKmBnKjFK~NO`S`BaOcB?oK?pK?qK?rKSsK?}IlFeEdTuCfSyCdF}CoNkEdEmEqNoE?tK?uK?vK?wK?xK?yKbFzK?{K?|KoSqJpSsJrSuJxTrJqStJhRmIiRoI?}KeA~KcFkJnTvCkSzCnB_L?`L?aL}SgCmP~EvPnB_TrCrPbFjEdF?tGuEbL?cLnQqHpQsHkL_CtBwCtQ{ChBdL?eL?fLtBgLxMyDkTL_SPoRsIxShJ?|JhFhLiSfE_EiL?jL?kL?lL?mL?nL?oL?pL?qLnS_HyTsJ?rL?sL?tL?uLxEhHyEjHzEvL?wL?xLiUMwSR~EyL?zL?{LzDkAbKmAhEqAdKsAfKuA?|L?}L?~L?_M?`Mc@xCgS}CpTlEpNnEkBtKrTvKsTxKuTbJ?zKwT|K|UyCoT~C?aM?bM?cM?dM?eM?fM?gM?hM?iMaEeEp@jM?kM?lM?mMoUo@uFN_O_BaScB?`J?nMhAlE~UoE?oM?pM?qM?rM?sMvUlA}LpAcKrAeKtAlD|LzUtM?uM?vMyOxFzOzF|O|F~OlDdA~FpEwM?xM?yM?zM?{MaV{KS|M|EeEzFzCnBdLgUfLS}M?~MuFcI?_NoB`N?aN?bN?cN?dN?eNcW{CnNjE{FmErBtKyFwKtTyKbFcJdSeJPOmDR~EtI?fN?gNc@uE?hN?iN_UjAuP_FiF`F`TuCsEdFrFuG?bL?jN?kNt@|CyDjEjWnExFuKpFwKlWbJcSdJtVmAwUrAwVuAyU}L?tM?lN?mN?nN?oN?pN?qN?rN_FfDcMnB?hDeMgC?jDgMlD{DmD|DsN}DtN?uNt@vN?wN?xNM{G`Q}GbQ_Hp@lGhPkE?nGaGPeL`BmF`JpVkEqTnEyWvK?yNeUrHqQtHSaE?zN?{N?|N?}N}WnAkDpA?vJfF~N?_OpUtJM}C}UmEkWuKpFyNtXsH]`O?aO{FnEkBbO?cOqLlC?dO]jExWoEoFuKzWxK`VcJhUpC?jGpXQ`OaBpD`JqXlE|FtKyFyN}XtHqWmA~S~EqF`FsWcFyPuGvEeOjL}BqBvB?}DrEgKkFiKhTfO?gO?hOjYnAtD{DC|DoA_BnVoK?iO?jO?kO?lO]~C?mOlSnJdXgDuRgCgXkDwRmD|DoDjBnO_GcJbYkErXoEdYvK_VyK?oO?pO?qO?rO?sO?tOM_L}TaLvYnBeXiDvRlDiXnDpBuO?vOqY`BmFwO?xOoMyDqA}DnYhKgTjK?fO?yOe@zO?{O?|OzTnI}EpIkRjCIrIgG~Dw@lE|FoM}F}O?~OiZpCfThK?_P?`P?aP?bP?cP?dP?eP?fP?gPsZ~OlX|GaQ~GPhP?iPmBjP]kPbRiIfZaBpDdBqKfB?lP?mPjGqCfAgKkF_P{BaPvZcPxZeP?nP?oP?pP?qP?rP?sP?tP?uP?vP?wP?xP?yP~ZrC?gK_[`PuZbPwZdP|BnPnGzPoG{PjA|PJ}P~XaO_YoErNqEsNsEv@mOuYoJoA~P?_Q?`Qv@aMbVcMdVeMfVgMhViMhGhC?aQlTrK[bQgAcQ?dQPeQ?fQoAgQ?hQ?iQ?jQf[gKoYjKiTlK{[hKjZkQ?lQ}ZbBbSmQ?nQ?oQb[tP?pQ?qQ?rQ~To@qZmErBoMzZsM{Z}GmXo@b\nExFsQ|LaDe@zNuX|N|ZkE?tQ?uQ?vQw@hIcRoGc\~Gd\oErGwQ?xQ?yQsAtK?sQrA~EkYrCaUuCsEaKbTyC?cQ}[cBoVmQ~[oQ~BpQ`\rQe@gEsApEeEwQk\yQ^oKrYjOsYlOoZoIjRqICrIxXoAdBqAxUtAxV}L?zQ?{Q?|Q?}Q?~Q?_Rv@lJo[_HS`R|EhEs\dE}Ro@xGiO?aRx[dQi\_Hk[kEdEnEkBoM}FqMsVsMuBdI?bR?cRyS}JzS_K|So@MjI_]iEvGsQsGhQ?dRl[pEeErEtNtEaZhDfXjDhXnBfBmDyYeR?fR?gR?hR?iRy@jR?kR?lRJmRtG_P`[bPh[ePmGoP?zPi[hJ?|P[nRcTzD]uHuQoR?pR?qR?rR^dB?sR?tRc@uR?vR^`J?mQq\sPpGpQ?wRbWfEtGiK?xR?yR{Qr@{Jt@}JzReCjKkZ{R?|R?}Rh@aJmWdJh@nMcYtKiYpHoQrHoARnWuIrRwI?~RjVfEb^kE?jRp]lR|GaMs[dMeVfMgVhMiVdEy\pAvVsAvF_S}YpOyBrO_ZtOvAeBgLhBtKjBvKlBdGpFtOrFvOtFxOvFrA{Dh]`DuD`S]aSCbSj]iDbZnBl]nDdZvOm^fB?cS?dS?eS?fS?gS?hS?iSWjS?kSiAlSzQ{Hs]`Pg[cPlGmS|@nS?oSyVyF{O{F}O}FoE~FpE`G`PbGaPdGcPfG?pS?qSqAwB}KyBfPpCgYkGr^gCwYlDcZoDjBqDlMrS?sSeAtSkUkJeCxRe_@jDk]oBxRoDzYuS?vSyBwS?xS?yS?zS?{Sb@bE`NdEb@zOmZ|S^wOgZtN`]o@m_@kDxYnDpB}S?~S?_TJ`Tt_@lDf_@pDyRrD?aT?bT?cTp@dT?eTlVmMRfT?gTuSzJe@oHzXuJnXmGhAjRf^lC?mRy@lErZpMrVrMfCsIpRuI_HhTxA{Jd]~J{S`Kt@iT{RyDvGuKeYyKvT{K_`@mE{XvKsXpHd^sH}_@kEoXoGy^kScCdRiPoGt\qEm[tE}\mJmSoJ{@jTsGkT?lTrAaQqF`SMmT|^aPa[dP|BnT`@oT?pTsFjLlUlLtFnL?qT?rTcCsTz[bIgHbPt]nPnGtToGrP~BuPc[wPd[yPwG_FrWrCn\cFkEuTlEgFmEvT?wT?xTjAkCJyTa`@hJjU}J?hL~@zT_^}RqB{Tv]zBq`@kLmUmLnU|Tl`@nJy@}T?~TxA_U?`U?aU?bU?cUMdLk`@kEe^kRq]lC`a@oJdQaHeQcHgQeHiQgHsUiHlQdU?eU?fU?gU?hU?iU|GvH?oRw]qR`@jRcHmRc@jUl_@yRf`@vK|YbJ`W|Kt@kU?lU?mU?nU?oU?pU?qUqUsL?rU?sU?tU?uU?vU?wUf]kItAlErBpEu\xQl\tHs`@cPlGnPt`@qP?{Pj[lC?}Pw_@nBs^oDjBxUjXuNPyU?zUp[_QqB{Ue`@zD_b@dP|BmSW|U?}UdHrE{@jOw\yDR~U?_V?`VwWnHnCoBn_@pDx_@aVcHbVuB_NeWaNgWcNiWeNRfO?cV?dVy@hIgCqAz\uA_XzQ?eV?fV?gV?hV~^zFzV}F`_@_G?wM~VyM_WiV?jV?kVz_@eT{_@oJ|a@nE`YcOIdOnb@rA~W|L~FlV?mV?nVaXpNcXrNMoV_AlE}a@qE?wQv\tHwApV?qV?rVbBsV?tV?uV?vV?wV?xV?yV?zVaC{NvX}NpCmD?{V{B|Vvb@lMmVoJrCnDpB}VtAnGbc@mMrHoDg_@gC`FrSi_@jC?tSk_@fEe@bEbHeEq_@{OnZo@}B~VlE_W?`WxAtIqRvI?aW^bW?cW}BdWz`@lC?eWnC`FfAfW?gW~KzBkHtLrUxE{NjAkQiH?hW?iW?jW?kW~DtUya@vUza@tJlZ{O?|Sw`@gCpPnB`UaFxPdFrFlW?mW`@tQf\vQn[mJm`@_H`@nG[nW?oW?pW`@lE?qWa]pM?}OtZsMwArW?sW|Ju@~JtW?uWJfEj@lEhYuK|XpHj`@tHra@wK{WzKxb@oEqVpM``@sMqAvWed@xKfYdJid@yKk^qOiGsOsHpD?nO_GzKp@wW?xW?yWoBzW?{W?|W?}W?~W?_X`RgIeb@ePmG`X?aX?bX~@gT{a@hEhc@cEfHqKzGeEsa@lUta@nU?cX?dXuBeX?fXwc@mBwPbFbUtG?gX?hX?iXaGjX?kX?lX}b@gPec@oJhGmX?nX?oX?pX?qX?rX?sX?tX?uXrHsNgCvX?wXe@}ImTfEyGpIpZkCJrIRxXMcK?yX_AnGzd@nByc@bF{d@lWtAhI{`@|J~d@_HaWkIfa@_HyHoO~YqOjd@tOPzX?{XW|X?}Xtd@fEdGwNYnO{YdJp^aDr[bMcVdMh^gMv[dEfCSwJhJ?~X?_Yc`@o@^`Y?aY_AhI~AbOaYkCJdO{@bYCcY`BmSyZpMad@~Okc@fF?_WvA|E~\kIj@nGo]kRea@mRb@gEcBgA`KiA}BdY?eY?fY?gYxe@}E}HeEuHfN`BnP?hY?iY?jYYqDh_@sSj_@}Je]`K}^oSqa@zBpc@uLjHhWrc@jWtc@eCqDtUuc@wUwAs@xHv@?tWbd@lCyC`X?kY?lYmc@hJIeWie@o@PeKrAiCCnCPmYCnYeCoY~b@nE`d@qMcBpYyHbJrd@dEdW~Mqb@{F__@lD|V_Gsb@xM?qY_a@o@_BrYg]o@qd@iE~@sY?tY|H`FlYdFuWvGwExGzPzG{@aRsf@rCx`@dFtf@wG?uY?vYce@qIaf@gC`FsDmMuDnMwD?tNWwYCxYga@bHfQdHhQfHjQxEvHhHtUdUja@fUka@hUma@o@uHuI_HxI?yY{GbRc]hJiH~JzFsG|H`SyCoP?tTu]|Pfe@iI|@cSt^eSv^gSx^iSgCvJyX_Owf@aFzc@eFy`@hFkOjFmOlFoOxEvHmA?zY?{Y?|Y?}Yb@}IlFhErf@o@|_@pHY~YC_Zge@}J|`@kJaa@`Uba@bU?`Z?aZ?bZ?cZyd@tH~ApE~a@yQdf@xE`g@iHqc@iWsc@dZ}E}KeAeZ?fZcFgZwg@qE|@gBhLjBc@hZCiZgGjGwC{M|WeJMfJ?jZ?kZhb@kOtYyDw@jRyf@rDzRwD{f@uNmg@bFaTlZCmZeh@uCtWtGcUjNd`@wDhZzDv@nZ?oZ?pZ?qZdHwQfH_FiF`SfCrZjAsZre@_K_d@qWyb@kC|f@jCIxYgh@cFmYbLdUpHkItZ?uZah@kGpHsAvF|L~FlN`XnN|b@qNwHvZ?wZhe@o@}CaT?xZ?yZbf@~JaCzZ?{Z?|Z~AtKoBvKi`@qHfUtHaBdFxf@}Zmf@|F{VnB_P_GdIqYwHsWxHzRW~Z?_[g`@nEe\`Dsh@wZue@cOze@oGrg@~IaFeEh@mQ{]tPuG`[|CpPu`@sPpGuPv`@xPmCgP_Ba[}Cb[?c[~AoMbg@vIsR~Rje@pOl^sOkHrUxa@tUef@tJ}c@nJ_DeFgIiFlOkFnOmFeFzYpg@d[kXxNb@oHxAyL?e[?f[?g[kd@aH?zWld@|Wmd@~Wod@fIjCh[Ri[?j[~Bk[?l[?m[?n[wCiVub@kVWvEyNxEhInAeGvJch@gJmh@_YtBo[ci@pMwe@sMih@p[?q[gi@fFjOhFng@kFii@xEhIzYki@wN_e@wDy[fQ{GeI`Z`Lle@r[a\aLhg@oG?s[`b@t[iAu[k@v[{h@}Frb@`Ga_@H?cGbPeGdPpSyCw[?x[eg@yDsAoM_h@rEcd@mEh`@yNnIzLbj@lDnf@wMtb@zM?iVkIlOcIzKkf@oErGrExh@aHdd@qH~HeLfg@{Hlc@cW`i@nQ_\sP|]`[gHy[|@lPig@dSu^fSw^hSmIwI?hTkj@{Ksj@|K_DuTgIvThHxTk@yTRz[rC{[ve@lC?|[Y}[?~[[_\?`\?a\jTjCInK_j@aLwGqKo`@lT_DtGuEb\?c\nc@rC?fWoc@yBt@d\aBe\Cf\uIoQr\wRoh@oEoFaHmj@rHzCkYgf@iEdg@cRb`@_K?g\?h\yBi\?j\?k\?l\?m\?n\`BfP?o\nj@fLv@vHna@pRx]rRjj@nB|h@wMrIuSo_@qOiGp\?q\|Cr\?s\?t\me@xNcBu\Cv\rC{V{Bw\?x\n`@yC?sGif@jCInC}f@cHha@fH_g@yErDhHyEy\de@lC?rIej@x[z^yC?zHnk@o@rh@tAlD_SzHwS?z\?{\|QbIR|\|j@uGvEwG?}\fb@}UzIcQsF~\?_]?`]p_@cE`BnT_I}O`k@jCIf\ek@~F}VxMof@nL?|Tth@bTxd@fX}h@oEfd@qMbi@c[nIe[ni@g[zi@gFmEiFhi@lFog@yEqOoFsOqFuOsFwOuFlf@zKxi@yCp\dQoI}Oui@wEeFnAeGa]k@b]ij@nE~h@aD`h@hBn^kBj@}Twk@cT~@c]?d]fi@oJ_AjRw@tQ]e]?f]k@g]Ph]?i]bl@iBiLlBak@sPpj@~MaDpEi]sE{IbLvWkNxIbOwIdOaCj]?k]?l]?m]?n]?o]?p]kh@gCxc@oB?q]?r]?s]ob@gVoH{R?t]?u]?v]jb@aH?`NfWbNhWdNdh@kRo^jCI|DkVkMwb@_Hpk@uA?w]mHhU_l@xEvi@oAdBvXbD|Lzb@mV{b@oNbXqN{e@dEjl@cOj@hIjIzKal@oEj\xQYxUdb@zBYx]?y]n@z]?{]zf@xDz]vRxl@y]yl@{]zl@yDy@tQib@|]?}]?~]d_@jGzj@o@`I_Wph@uZaDoMb]rMh\iI}l@kG`c@qV?_^?`^?a^yG}KiIfZ~g@_Ktg@~Jel@i]b@zN?zZvh@|Zhj@sEyj@kCJnKsIpEil@tE`Ib^pi@zWqi@}Wnd@_Xpf@kI?c^?d^?e^?f^aBaKo\cQ?g^Ch^rj@xIcg@dEpItN_JrVac@tV?i^wIj^Sk^`j@o@vk@_GdIyM?l^k@m^}j@fW~j@zBcm@tEvAn^am@_K_AoTvIeSjg@hSgj@pMll@mB{Dq]ml@o^?p^Cq^pa@kRwAr^?s^lm@rQ?t^?u^?v^?w^?x^?y^?z^kb@dNhf@fK`m@oGjf@yBw[yCud@mUua@cXtl@}L{U_M~`@lLtF{^iI_Y}e@eY_f@gYjm@yItR{I_B|^sAbOug@aUca@`Zvg@bZ?}^zGhEdc@oG_J~^?__@ic@fExIpE{l@`_@?a_@{\}Q|\_Rg^bMoe@eMu[hMj^eE|e@hArm@nBfBq]sm@b_@?c_@?|Vik@`P?w\cIcJ_BxWjc@|OeD~L?d_@vd@cXlh@hJ?sZnh@`KvAsRlk@dH~f@gHjHjH?dUag@gUla@iUbDw]mHkNvc@|Oum@u^vm@w^xm@y^zm@bNql@eNne@cMt[fMi^iMaj@hJIv[Se_@jh@xQdi@qOuj@cOI|[vf@yCkk@yDa^bJh@f_@_IqMjn@_M`Jg_@?h_@?i_@ul@rNRkQ}HhEan@bUda@rMdn@qEwl@{Kgn@iAeDzQ?j_@?k_@|@l_@{@m_@Cn_@ee@oGwCuSfk@rO?p\mm@qU`Jd^gm@o_@?p_@?q_@?r_@yg@yEmk@iH{g@jW?dZ|g@jC?eZ}g@jJ?gZ~k@~Oin@dJfl@jB`f@gN~c@oGim@jCIh^jFs_@?t_@Mu_@rk@`]{n@wQ}IpExg@tHsn@kCJv[xk@v_@?w_@WhNpWzBjIcJqn@dMpe@hMfn@fEte@iIfm@yDaJwMrI{Mc@yHuh@{Zwh@fL~Ho\jCt]?x_@?y_@?z_@gl@tPuGwRoIqM~i@fIS{_@mCo\yIgPj@jRh@|_@fo@oGsHeRm]gRn]iRol@`Npl@cN|d@kX?}_@~e@~_@?_`@?``@cb@wDhh@zB_k@zBhl@qE_c@xQ_i@kCff@t@~]o@pIxDwj@`\vIa`@?b`@?c`@?d`@mo@rMyIo\aDtKc^qHtm@aLzn@cUvo@o@vl@kCsg@qHaBrGun@rOao@kB^e`@ei@f`@Cg`@eDtM?h`@nl@hV`@hIon@v^wm@x^ym@z^{m@eNgb@sEzCi`@mi@pHhd@yCwn@zDho@zDcn@__@bHhE{IvGwE}\_n@mLbD_SzHrOlj@vKzh@rH}ItKm\`D}CrSfc@tShF~JqAj`@k@k`@so@lCse@aYPl`@w@}T|CzPgg@lCcJlXtE_`@Wm`@Cn`@qm@}Omn@`Vj@tQio@yC`p@zBxn@gP_m@sM}n@e^?o_@~n@q_@co@t_@}d@pMqk@mP~m@nUwd@dXkm@uNdo@_]sk@nHjG~DaJ`Gcj@cGdj@fGePhGvn@kCJ|[tn@yQgo@eMen@iMye@hEri@j[si@l[?o`@?p`@?q`@?r`@?s`@?t`@?u`@?v`@fJcXnn@o@bk@lYnC`SpCw`@?x`@jp@tHxo@rHnp@iERy`@?z`@}o@w^pn@z^r_@xObe@~IaFhEqp@_JpC{`@?|`@?}`@fp@f^zIsGep@pMjC|Rtk@dEeJkNjo@x_@ko@z_@{o@lBuk@o\`@}TsItKyh@yNbn@iEuI~`@?_a@nm@`Kip@lCYuOkp@fMrn@dEyo@yCwp@cQ`o@eJmIaW_p@tEuo@sMhn@`Shk@jCIv\lo@pQ?`[|n@|Krl@lMcc@_Hyi@q[vp@gMqe@eEcJ}_@po@_`@h@`a@ln@eHia@xEzg@jHzEaa@?ba@qg@tE|o@wD|Ica@zo@sO|c@uQbp@bJfJoUva@qUop@{HmCeLfj@zDkg@wJtSyJtp@eEdk@oRoa@rRap@{^{TjJhp@}Owi@hJhSjJbJcJbJzKc_@da@?ea@?fa@?ga@?ha@|TfEY}Su_@_Ttj@fF{i@vThHia@s_@uN|IjN~@ja@mb@iIhm@lZq^{Hom@pTzCaXpd@o@rp@yDwo@lCcp@sQoo@pMsl@yEiEoAdBvJfFxJsp@qMdm@qEro@yQcCiQxGka@?la@yn@lQpHma@?na@?oa@?pa@cGqa@?ra@?sa@?ta@cGua@?va@?wa@?xa@ck@hJiHhLpp@ya@?za@gp@r_@lp@dXzp@oG|k@cQ{p@jAuVa]sd@rKyk@hF|i@lF{k@jAiDnFrOwN`n@cO|p@iFzk@mFji@{Y?d[to@yDno@gIyp@sZkn@o@hJqQhJwR`e@wXoH{a@eJhU}p@zD}`@yCxD|a@?}a@ai@dEeo@xQtAjRdl@_Hpm@fSqj@iSxp@~O?~a@</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??pA?Cs?D??C??P@?kf?E??F??@V??F@G??C??pH?_O?H??I??@@?k`?J??C??@B????K??L??`@?gD?M??N??P??KD?O??P??@B????K??Q??p??cD?R??S??PG?GC?T??S??`@????U??V??PJ?[D?W??X??PK?_A?W??Y??Pg?cE?Z??V??`@????[??\??@T?w@?]??^??P@?oA?]??_??`A?KC?`??a??@A?gA?b??c??`J?{O?b??d??`@?cP?e??f??@A?kR?g??h??Pf?WE?i??j??`E????k??l??PD????m??n??`C????o??p??@v?WU?o??q??@n@[b?r??s??P@?K~Dr??t??`]?[?Eu??v??`D????m??n??@D????w??x??@B????w??y??p?????z??y??p??_B?{??y??PG?C]?|??}??PD?oq?|??~??PP?Wt??@?@@?pE??n??@?A@?P??cp??@?B@?`M?cT?C@?D@?`A?sS?E@?F@?PO?Sq?G@?H@?pI?cP?G@?I@?PE?OW?J@?A??A?????K@?C??pS?WC?L@?M@?@U?wL?N@?O@?PJ?sC?N@?P@?@o?oJ?Q@?R@?@A?SG?Q@?R@?`C?gG?Q@?S@?`E??K?T@?j??`B????U@?V@?pC?Of?U@?W@?P??gf?{??W@?pD?Kk@{??X@?PA?sk@{??Y@?`D?Km@Z@?[@?P@?sk@Z@?[@?P@?{k@|??X@?PL?w\??@?A@?`@?gp??@?\@?Pf?Cs?]@?^@?`a?sz?_@?P??`hCWr?_@?`@?`A?_`?a@?A??A?????b@?C??`eCwx?c@?d@?pB?g@@e@?f@?P@?WI?g@?A??A?????h@?C??`B?WM?i@?C??P@?[H?j@?k@?`g?kT?i@?C??P??SH?l@?C??`G?sK?m@?C??@@????n@?o@?@L?WL?n@?p@?@R?kW?q@?r@?`A?So?s@?r@?PR?ga?t@?C??@@????u@?v@?pS?s_?w@?x@?pN?[W?b??y@?`H?[e?z@?y@?pb?[BCz@?{@?@I?ccB|@?{@?pF?gD@|@?}@?P??kA@~@??A?P???n?@A??A?@?????~@?A??A?????]??^??pE?CB?]??AA?@A?GD?BA?AA?`@?SG?CA?AA?@@?[d?CA?AA?pA?{d?CA?AA?pb?[g?DA?y??pP?WI?CA?EA?@@?gJ@FA?GA?@I?sA?HA?IA?pE?wLAJA?KA?P@?kS?LA?KA?P??CF?MA?NA?PC?WH?MA?A??A?????OA?C??PM?sm@PA?QA?@R?w^?RA?SA?PY?wF@TA?[@?@A????DA?UA?P??ST?DA?VA?@X?_X?WA?XA?`??OV?WA?VA?@C?oV?WA?YA?PO?k\?WA?ZA?pX?[T?[A?\A?PL?sD?]A?^A?Pp?oF?_A?`A?@??GB?_A?A??A?????b@?C??P`?Kp?aA?bA?@??Kz?cA?A??A?????K@?C??@M?KC?dA?eA?@D?_G?fA?A??A?????gA?C??@@????hA?iA?`@?oW?jA?iA?Pb?{^?kA?lA?PV?[m?mA?nA?`@?GP?mA?nA?`V?CR?oA?P??`E?sH?pA?C??@~?wj?qA?rA?PJ@wd?i??sA?P@????m??tA?P?????uA?vA?@B?__?wA?vA?@?????xA?A??A?????WA?YA?pQ?o\?PA?V??p??OQAPA?yA?`L?Wz?PA?zA?`M?Wy?{A?[@?@C????WA?|A?@@?o\?WA?}A?@j?OX?~A?[@?@B????WA??B?P??_\?qA?@B?Pz?SO?PA?AB?p??SOAPA?BB?`[?KI@CB?[@?@A????qA?DB?PN?KP?EB?FB?`q?WR?EB?GB?pV?[F?EB?HB?@O?CK?IB?bA?@??gP?JB?A??A?????n@?o@?`p?cM?KB?LB?pH?oh?MB?NB?PD?Oe?KB?V??p@?se?KB?V??@i?[j?PA?k@?p@?KEAOB?SA?PU?Gg?PB?QB?pE?ob?RB?C??`??G]?OB?SA?Pc?sg?PA?SB?@O?We?TB?[@?@A????DA?UB?PL?CU?WA?VB?@H?cJ?qA?VB?@I?_V?u@?WB?@r?WY?XB?C??@D????u@?YB?pe??]?w@?ZB?P@?SE?[B?\B?PF?gD?PA?]B?`???H?PA?]B?p??SPAPA?^B?PB?Gv?_A?_B?P??WA?_A?_B?@??SD?qA?rA?pv?Wd?`B?A??A?????[A?\A?@U?GE?PA?yA?PB?Cz?KB?V??@W?Gj?aB?bB?@d?wF?aB?cB?@s?GS?aB?dB?`R?kO?eB?fB?`@?_fAeB?fB?PI?_hAgB?hB?p@?Co?eB?A??A?????aB?dB?@I?KO?gB?hB?@C?Co?iB?jB?PI?wmBEB?GB?PT??F?kB?lB?@B?OL?kB?mB?`I??N?nB?oB?P@?C`@pB?oB?@F?GO@qB?NB?@E????kB?rB?p]?GO?sB?tB?P??oA@uB?vB?pG?oI?sB?lB?`G?K@@wB?A??A?????qA?@B?@L?[M?u@?y??`b?KE?n@?xB?`X?OZ?mA?nA?`@??O?mA?nA?`T?{Q?n@?p@?`I?{U?yB?A??A?????DA?y??`m?SJ?WA?A??A?????qA?rA?Px?Wd?PA?zB?`E?CfA{B?SA?@L?{w?|B?[@?@C????WA?}B?@@?c\?~B?[@?@A????WA??C?PK?{Z?qA?@C?`f?gS?PA?AC?p??WGAPA?BC?PE?{l?PA?CC?PQ?Sn?DC?NB?@A????qA?EC?P??gS?qA?FC?PF??a?GC?lA?`J?cG?HC?lA?pJ?gG?IC?C??Pv?kF?JC?KC?pc?O\?qA?LC?`A?w_?qA?LC?@G?K`?MC?\B?`??{|?MC?NC?`??Cu?MC?OC?@@?kT?MC?PC?@??GR?QC?A??A?????RC?C??pF?SI?SC?F??PL?Wd@SC?TC?Po?[f@UC?VC?PB?wH@WC?XC?`A?SV?RB?YC?`??K]?ZC?SA?`R?os?[C?SA?PY?wk?\C?NB?PA????]C?^C?`M??B?_C?`C?PO??A?_C?aC?PB?OC?bC?P??@A????_C?cC?`??KC?N@?dC?@W?GN?N@?eC?`??cO?fC?gC?`N?CJ?hC?y??`@?GA?DA?VA?p\?[Z?PA?yA?@F?Oz?{B?A??A?????aB?bB?@f?{F?aB?iC?pK?wS?kB?mB?@??sM?pB?A??A?????qA?@B?P{?SO?jC?A??A?????WA??C?`M??[?PA?BB?PB?GH@qA?@C?PL??S?EB?kC?`L?[S?lC?xB?@F?oE?mC?xB?PX?{B?HC?y??`D?{C?mA?y??PF?oM?j@?A??A?????EB?FB?`v?cR?eB?nC?PD?gn@eB?oC?@H?{r?eB?pC?p@?Oz?iB?tB?P??C\Bb@?C??puCWy?aA?oB?`J?[]@qC?NB?@A????b@?rC?p??Wy?b@?sC?@D?K|?tC?V??P@?sN?uC?vC?`C?sz?wC?xC?@@?Wo?yC?C??`G?SJ?zC?C??@@????wC?R@?`gACs?{C?|C?pe?OJ@}C?~C?`D?kA@?D?@D?pD?{E??D?A??A?????aB?dB?Pb?CP?aA?\B?@D?K\?aA?\B?p@?W[?aA?AD?p@?ON?aA?AD?@L?{M?BD?A??A?????EB?GB?pX?oF?EB?HB?PA?wJ?CD?bA?@??_i@DD?A??A?????qA?@B?`|?OQ?PA?BB?`e?[I@ED?A??A?????N@?P@?pr??K?FD?GD?pH?gN?FD?HD?@L?CT?DA?VA?`H?WW?ID?JD?PC?GU?KD?lB?@??CF?KD?A??A?????W??X??`H?[A?W??LD?@E?OC?W??MD?@B?{A?ND?bA?@??[|?OD?A??A?????kB?mB?`C?wM?PD?y??P??sG?EB?FB?`r?[R?QD?RD?@C?S[?n@?o@?@N@KO?n@?SD?@P?wS?TD?iA?`P?ob?UD?lA?@B?ke?wC?lA?pL?Gl?wC?VD?pJ?gm?WD?A??A?????]??_??pC?CC?]??lA?p@?gC?XD?YD?P@?_w?XD?y??pC?{e?ZD?bB?@Z?[EBZD?[D?PK?KHBZD?\D?@_?sKBZD?]D?pz?wPBZD?^D?`p??[Bu@?YB?@c?o[?aB?dB?PS?kO?eB?HD?pA?o[BgB?HD?@P?Sd?CA?AA?PG?Cf?ID?y??Po??G?kB?_D?P@?GD?`D?aD?P??[m?sB?bD?p@?go?cD?A??A?????EB?FB?PU?OQ?EB?dD?PS??N?i??sA?`@????eD?h??@c????m??n??PB????fD?hB?`@?KW?EB?HB?@[?OK?QD?~C?`??KJ?gD?~C?PD?Wc?gD?hD?@G?OM?E??F??`E?GE@E??iD?@`?SA@jD?kD?pA?[w?lD?mD?PT?KV?lD?nD?@@?_S?oD?A??A?????n@?p@?@P?_W?pD?y??P??wG?qD?y??PA?OA?rD?y??P@?WA?sD?A??A?????]??lA?`??gC?k??tD?`B????m??n??pA????fD?uD?PN?SY?fD?vD?pC?w]?wA?wD?pK?{T@WA??C?@O?C[?WA?xD?`B?G]?EB?FB?@i??R?yD?RD?@B?o]?W??Y??pl?sE?zD?A??A?????{D?[@?@C????[A?|D?@@?GE?[A?}D?`x??H?[A?~D?`@?CI?qA?y??@J?GD??E?A??A?????b@?C??pgCwx?@E?A??A?????CA?AA?@e?wg?DA?XA?PF?WQ?PA?zB?PC?CfAOA?A??A?????aB?cB?PQ?{Q?kB?rB?@L?WN?AE?oB?`F?kC?BE?NB?@C????kB?CE?`B?_N?DE?EE?@B????EB?FE?`??CF?`D?aD?p@?[m?GE?aD?P@?SC?HE?A??A?????wC?lA?`S?cl?IE?h??`Q????EB?FB?`H?oP?QD?y??`??[F?gD?y??@B?_D?lC?xB?PB?gE?lC?NA?pP?KE?EB?FB?pi??R?JE?KE?@??oB?aA?A??A?????WA??B?pA?c\?fD?uD?`U?gY?LE?[@?@C????U??ME?`G?{G?U??NE?`??sI?U??NE?`@?cI?OE?y??`@?C@?OE?y??p??c@?fC?y??pI?_D?QD?~C?`??sN?gD?~C?`B?sr?b@?C??PBASs?PE?V??@@?WB?QE?C??@@????wC?RE?pR?gj?}C?~C?`J?GB@?D?SE?@??sG?TE?A??A?????]??lA?`A?gC?UE?VE?@??CR?WE?A??A?????w@?x@?`[?sW?XE?YE?@A?kH?XE?YE?pH?cI?XE?ZE?@??wK?[E?A??A?????EB?HB?`W?GK?\E?EE?`A????]E?^E?`B?cC?_E?EE?@A????`E?aE?@@?oO?bE?EE?P@????cE?dE?`???D?eE?EE?@@????`E?fE?@D??K?aB?bB?@X?_F?aB?gE?pG?kI?QD?~C?`??WN?gD?~C?p@?Gq?ID?y??pY?GF?kB?rB?`^?GO?pB?^??@@?W`?pB?^??`B?Cp?pB?hE?@A?co?iE?A??A?????XE?YE?`k?wJ?jE?\B?`W?_W?kE?A??A?????]C?^C?PA?WA?OE?lE?@C?gA?M??mE?pD?KC?M??GD?p@?KE?kB?nE?P@?CE?aB?cB?pn??S?aB?cB?@p?CS?QD?A??A?????W??LD?`O?_C?oE?NB?@A????W??pE?PA?_C?qE?^??PA?Ge?qE?rE?@M?Sf?qE?PC?@??su@sE?A??A?????XD?YD?@??_w?XD?A??A?????u@?y??``?GE?KB?tE?`@?{g?lC?NA?PD?oD?uE?vE?PA?kU?jE?\B?@@?GV?wE?xE?`W?gn?wE?yE?p??kw?wE?zE?pK?Cy?wE?{E?pE?oS?wE?YD?pH?{X?wE?A??A?????WA?VB?PJ?gJ?PA?^B?@F?Sv?ZC?A??A?????qA?DB?Pe?cP?qA?LC?P??w_?|E?A??A?????kB?CE?@E?cN?aB?dB?p_??P?qE?}E?PM?wI@qE?~E?P`?wj??F?A??A?????qD?y??P@?OA?rD?A??A?????EB?GB?`E?WE?JE?@F?p@?gC?kB?rB?pJ?WN?i??sA?p@????BE?A??A?????mC?xB?pV?{B?qA?y??@t?gK?n@?y??PJ?sI?TD?A??A?????DA?XA?`C?SQ?DA?AF?PE?[U?PA?BF?p??kSAPA?CF?PB?[A@EB?HB?p^?SK?u@?WB?p_?gX?kB?_D?`A?GD?e@?DF?P@?[g?EF?FF?@U?gM?GF?HF?P@?WH?IF?\A?@?????JF?A??A?????u@?WB?`Y?WX?KF?A??A?????CA?AA?pq?_h?PA?LF?`@?{PAn@?y??PM?{I?aB?dB?p]??P?eB?MF?PB?{RBgB?MF?PX?S[?pB?^??@u?or?pB?NF?@??sn?[A?}D?pz?CH?PA?OF?p??_FAPA?PF?PE?Wh?PA?QF?PR?oi?RF?[@?@A????[A?SF?P??GH?WA?TF?@C?sR?ID?UF?pD?OQ?JE?KE?pD?wB?W??Y??@s??F?]C?VF?@D?CA?WF?A??A?????EB?GB?PN?gE?FA?GA?@??cA?XF?A??A?????ID?UF?`G?SQ?]A?YF?P??GL?]A?ZF?@V?GP?]A?[F?`??oL?`E?\F?p@?S^?]F?^F?P@?wR?]F?_F?PF?_o?`F?C??@A????`E?aF?`??W^?bF?cF?PG?CG?dF?eF?pD?cB@dF?A??A?????]A?ZF?pC?kN?`E?\F?`??S^?fF?tA?P?????`F?A??A?????]??^??PA??B?gF?hF?@??_h?lC?A??A?????qA?rA?pK@wd?DA?VA?P^?S[?PA?BB?@F?SH@RA?A??A?????W??Y??PE?WD?iF?A??A?????]??^??PC??B?WE?@F?pI?kL?jF?y??`L?OB?KD?kF?`A??G?qA?y??pq?gK?n@?A??A?????ID?y??p}?cG?ID?lF?@@?wQ?mF?eA?`x?cL?nF?C??P??gL?nF?C??`L?gM?QD?y??p??gE?AE?oB?`@?gC?kB?mB?PO?[O?oF?pF?pA?[[@nB?A??A?????uB?vB?`F?oI?aA?qF?@A?CV?iB?tB?`@?cXBXE?YE?p`?cJ?XE?rF?p@?SN?qE?\A?`??oa?qE?sF?pD?_b?qE?tF?PA?GT?uF?vF?P??cE?aB?cB?@M?sQ?DA?AF?p@?ST?W??MD?pK??B?W??tF?`??sC?jF?y??pI?KB?qA?VB?PE?SV?wF?[@?P?????xF?yF?@??ki?zF?hF?@??oA@{F?A??A?????kB?mB?PH??N?i??sA?PA????|F?tA?P?????qB?A??A?????DA?VA?`Z?cX?CD?bA?P@?_i@DD?y??PC?ci@}F?bA?@??oR@~F?A??A?????DA?y??P@?[D??G?A??A?????qA?@B?pH?[M?u@?A??A?????nF?C??@Q?gM?[A?~D?@??CI?qA?A??A?????Q@?S@?P??sJ?n@?y??`H?gI?mA?@G?@@?_X?l@?A??A?????ZD?[D?@Z?oHBw@?x@?@N?[W?RA?SA?pb?GG@EB?GB?@S??F?DE?A??A?????FA?GA?pJ?sA?MA?AG?`F??]?MA?BG?`C?c]?CG?DG?`@?Ci?CG?EG?pK?sj?CG?FG?PK?Sl?GG?A??A?????u@?y??pU?wD?q@?A??A?????WA?YA?PS?s\?ID?UF?PH?SQ?FA?GA?PH?sA?HG?A??A?????fC?gC?PM?CJ?hC?A??A?????u@?YB?PD?_Y?IG?y??@G?GC?JG?h??PD????kB?nE?@D?CE?KG?DF?P@?[`?GF?HF?@D?WH?LG?\A?P??SM?LG?\A?PC?{M?MG?lB?@??KF?MG?A??A?????gB?MF?pj??\?u@?WB?pp?WY?NG?sA?@B????OG?tA?P?????XB?A??A?????u@?YB?PQ?SZ?IG?PG?@I?gF?s@?A??A?????aB?bB?@`?oF?aB?QG?@Y?gN?qA?y??PK?GD??E?y??pH?Sf?ZD?[D?ph?GIBqA?DB?PD?_O?DA?AF?@C?WT?WE?@F?`H?kL?jF?A??A?????EB?FB?@G?oP?ID?UF?`A?KQ?kB?mB?@N?[O?kB?A??A?????fC?y??pA?WD?RG?A??A?????jF?y??PQ?WB?]A?ZF?pP?sO?qA?@C?Pd?cS?SG?NB?@A????qA?TG?`??cS?qA?UG?PA?_Q?VG?A??A??????E?y??`L?[f?WA?ZA?@f?CU?fC?y??PF?_D?kB?mB?pA?wM?PD?A??A?????]??lA?PG?oC?WE?WG?p??kA?WE?WG?@B?{F?JE?XG?`A?WB?pB?}E?`F??b?{C?|C?Pl?gJ@}C?YG?PD?w@@ZG?\A?@?????`E?YG?p??CQ?uE?vE?@C?kU??D?y??`@??C?qA?@B?@u??O?qA?DB?`F??P?qA?[G?@K?_L?{C?[G?`E?cO@{C?xB?PH?CF?\G?xB?@D??b?UD?y??`A?Od?]G?A??A?????^G?C??@@????hA?_G?@b?OW?oA?P??PC?kH?E??P??PN?sS@jD?`G?pC?ku?lD?mD?@^@sX?u@?WB?`y?O^?W??Y??PL?cD?aG?A??A?????WA?ZA?pa?kT?u@?y??PZ??E?aB?A??A?????qA?y??@l?[K?w@?bG?pJ?{N?w@?cG?@B?kJ?u@?YB?pa?o[?dG?A??A?????n@?y??PD?[I?MC?A??A?????XE?rF?@I?gN?XF?\B?`??WT?XF?OC?P@?GH?eG?A??A?????kB?nE?pB?CE?e@?fG?P@??M?gG?A??A?????jE?\B?pA?KV?wE?zE?PW?_t?wE?hG?p??{u?EB?FB?@V?OQ?N@?P@?@A@sK?N@?iG?PD??H?K??S??``?{B?jG?P??@B????K??kG?p??wB?K??V??@D?gD?lG?mG?pB?gF?lG?nG?`@?GE?G??y??p@?_H?oG?pG?@B?KY?H??A??A?????DA?UB?@O?GU?PA?PF?`F?[h?u@?WB?@\?_X?]C?VF?@C?CA?PA?BC?@H?Cm?[C?A??A?????ZD?bB?PT?OEBCA?AA?p_?[g?DA?A??A?????]C?VF?pA??A?\C?A??A?????qG?[@?@B????DA?rG?pE?oZ?wC?R@?PW?Wp?wC?sG?PB@[y?UD?tG?@M?gg?TD?r@?p^?{a?EB?kC?@I?WS?JC?A??A?????DA?VA?pN?_W?CA?uG?pC?GK@PD?\B?@A?{N?qE?oB?`Q?sW@N@?P@?Pf?cJ?N@?vG?`L?sL?T@?j??@D????wG?tA?@A????[A?\A?@X?KE?aB?bB?@Z?cF?aB?xG?pO?oJ?b@?C??`~Cwy?yG?NB?@@????b@?zG?P??wy?{G?C??@A????b@?|G?`??{x?c@?}G?`@?OA@~G?bA?p@?wI?]A?YF?pC?WL??H?@H?`??cT??H?oC?PA?OQ?\G?xB?`A??b?UD?A??A?????W??LD?P@?GC?aA?y??`A?oH?EB?kC?PJ?WS?JC?y??`A?wW?GC?y??P@?cF?AH?V??`@????U??V??@L?WE?U??BH?PC?cG?pA?C??`@A[l?{C?CH?P@?gB?{C?CH?P@?[G?hA?CH?`T?sR?hA?DH?@Y?wT?{C?EH?@@?{K@wB?qF?pD??g?FH?AG?`??wC?GH?A??A?????n@?p@?PM?_W?pD?A??A?????qA?y??PG?wC?yD?RD?`D?w]?W??Y??@D?SD?iF?y??`K?{L?u@?y??P[??E?aB?y??P@?KB?HH?h??@L????m??n??`A????CA?AA?@E?Cf?ID?A??A?????DA?AF?`??ST?TA?A??A?????]C?VF?PE?GB?PA?IH?p??oRAPA?JH?@F?w}?KH?A??A?????]A?YF?PB?SL??H?LH?PA?GY??H?A??A??????H?@H?pB?gT?eB?y??`L?OX?W??Y??`d?WE?Z??A??A?????[A?~D?PA?CI?c@?d@?@@?c@@M??mE?`G?OC?aB?xG?@N?kJ??E?y??pD?Of?kA?A??A?????HC?y??`A?{C?mA?A??A?????u@?y??PW?wD?MH?A??A?????ZD?\D?Pf??LBIC?C??pg?WF?JC?CH?P@?kW?JC?CH?pg?sY?sB?lB?@??oq?u@?WB?Px?O^?NH?A??A?????pB?}E?pC?wa?pB?OH?p@?om?PH?[@?@@????JE?QH?P@?WB?[E?r@?`??S_?IE?h??PG????RH?h??pD????fD?SH?p@?k\?qA?@B?@y?OO?CB?A??A?????EB?dD?`R??N?dF?RD?@B?_[?WA?xD?PA?G]?TH?A??A?????EB?HB?@@?wJ?nB?UH?@C?c^@pB?UH?`B?wG@}F?A??A?????]??_??PB?KC?eD?h??@S????PA?CF?@F?gA@VH?A??A?????N@?vG?pM?wL?FD?A??A?????IG?PG?`K?gF?s@?y??PG?S`?qE?}E?`q?OK@WH?[@?@@????aB?XH?@??CP?HC?y??PG??D?u@?y??PQ?sD?KB?A??A?????nF?C??`K?gM?aB?xG?`c?OK?u@?YB?pT?W[?q@?tE?P??Km?JC?CH?`h?sY?UE?VE?P@?CR?WE?y??PD?cB?JE?A??A?????mA?@G?@B?_X?qA?y??pg?WK?ID?YH?PQ?[W?ZH?C??@A????ID?[H?`@?WW?\H?y??@F?cM?]H?A??A?????WA??B?PC?g\?nB?UH?@A?c^@CD?A??A?????aB?y??PA?KB?b@?C??`kC{x?{G?A??A?????WA?YA?`P?k\?{A?A??A?????]A?YF?`@?KL?^H?_H?@@?wG?PA?QF?P??{h?qA?y??pO?[D?DA?UB?pM?CU?`H?A??A?????u@?WB?@i?CY?aH?A??A?????DA?VA?PK?[W?bH?lB?@??cA?bH?A??A?????lC?xB?PC?kE?mC?A??A?????qA?DB?@??WO?WA??C?PL?{Z?cH?A??A?????b@?C??@iCwx?e@?oB?`@?Od?dH?HF?p??sI?eH?HF?p??WH?EF?fH?PA?K^?EF?gH?pD?Ka?g@?hH?@??gI?iH?A??A?????JE?KE?P@?oB?jH?\A?@?????LG?A??A?????]A?ZF?@@?cN?^H?y??`??wD?^H?y??PA?cD?c@?d@?`A?c@@kH?A??A?????PA?PF?@H?_h?OB?A??A?????wC?R@?PvBCu?JF?\A?P??{J?JF?\A?pA?GK?qA?y??PZ??K?HC?y??PF??D?U??ME?`B?oG?uE?lH?@@?SZ?uE?lH?@??_X?n@?p@?`K?OV?mH?A??A??????E?y??`J?Wf?pA?A??A?????EB?GB?@C?OE?]E?nH?p@?cC?\E?A??A?????W??Y??@i?kE?oH?A??A?????qE?}E?`F@?L@b@?C??`cAgt?CA?pH?@H?cL@PD?bA?PA?SJ?qH?bA?PC?WV@pB?rH?@??cU@sH?A??A?????cH?[@?@A????WA?tH?P@??[?qA?uH?`J?cT?mA?@G?PA?_X?l@?y??P@?{J?vH?A??A?????w@?x@?@V?kW?u@?WB?Pv?w]?wH?xH?PU?oF@yH?C??@B????wH?zH?@B?wF@w@?bG?pG?wN?XE?bG?pD?{G?uF?A??A?????K??S??@Q?SB?{H?|H?@A?K@?}H?A??A?????PA?BC?`F??m?b@?C??pnACu?XE?~H?@C?WO?XE?~H?@E?SP?jE??I?`B?CY?b@?C??@yCgy?@I?A??A?????K??V??pB?gD?J??A??A?????aB?cB?@q?CS?M??GD?@B?KE?AI?A??A?????DA?y??PD?gE?qA?uH?PF?WT?u@?BI?`v?GK?CI?A??A?????N@?P@?Px?GK?N@?DI?pL?_G?b@?C??@`Bcv?EI?eA?pF?sG?EI?FI?`I?CG?GI?HI?@r?[G?GI?II?PZ?KK?EI?JI?PY?KR?~G?\B?@A?sL?OE?y??PB?k@?aB?xG?pP?oJ?JE?QH?@??WB?K??S??PF?sA?FD?[F?`N?GG?XE?bG?`M?CH?XE?KI?`??_L?u@?BI?py?oL?PA?LI?`@?GGAXE?ZE?PK?CL?aB?cB?PO?wQ?ID?y??ps?CG?XE?~H?PB?WO?wE?MI?@??KP?NI?OI?@S?{_?XE?rF?P??ON?PI?QI?@??sV?FA?GA?@J?sA?DA?AF?@D?WT?RI?A??A?????jE??I?`E?[Y?XF?SI?P@?w|?TI?y??`A?S}?UI?A??A?????R??S??pB?wB?FD?VI?@C?SF?EB?FB?Pw?cR?WE?y??PE?cB?JE?y??P@?cA?l@?y??PA?{J?vH?y??P@?WQ?WI?A??A?????aB?cB?PN?wQ?ID?y??Pl?wF?U??BH?`E?CH?PA?JH?PB?k}?PA?_B?@??WaAPA?A??A?????MA?BG?PO?K^?XI?AG?P@?sA?YI?AG?@?????ZI?A??A?????CA?AA?Pg?wg?hA?_G?p`?OW?gA?A??A?????jE?\B?@Z?_W??H?@H?`@?gT?[A?\A?pS?CE?{D?A??A?????W??Y??@J?_D?u@?y??pR?sD?[I?A??A?????\H?y??pB?SM?\I?]I?P??[M@\I?^I?`??cP@\I?^I?@e@CU@\I?_I?PF?G[@`I?bA?PA?SP?aI?bA?`A?KHAbI?A??A?????cI?[@?@B????DA?dI?PK?WY?qA?y??PH?wC?MC?y??`@?Oo?TH?[@?@A????WA?eI?`@?G]?WA?fI?`U??c?mF?eA?@u?cL?nF?A??A?????ID?y??Pk?wF?}C?~C?PK?GB@{C?gI?PJ?OK@lC?NA?@??gD?]A?^A?`B?GE?hI?iI?pE?k`?hI?jI?pR?{b?kI?sA?p@????lI?h??@n????qA?UG?`C?_Q??E?y??pG?Sf?DA?XA?PA?OQ?mI?y??P@?kJ?s@?r@?PU?ka?KF?KC?`??WW?KF?k@?pK?KT?{F?KC?@D?oV?ZC?SA?@L?cs?PA?nI?PM?{t?oI?NB?PA????wH?pI?pB?GG@OB?SA?`Y?Wg?`H?[@?PB????DA?qI?P??KU?rI?A??A?????DA?dI?`??sX?DA?sI?PB?ON?n@?y??@P??J?tI?[@?@A????WA?uI?@E?oU?</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1000000000;
    let startMs = 1668376113999;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","java.lang.Thread","run","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","java.util.concurrent.FutureTask","java.util.concurrent.Executors$RunnableAdapter","call","ok.dht.test.kovalenko.MyServerBase$$Lambda$208.0x0000000800d84678","ok.dht.test.kovalenko.MyServerBase","lambda$handle$2","ok.dht.test.kovalenko.utils.HttpUtils","safeHttpRequest","ok.dht.test.kovalenko.MyServerBase$$Lambda$204.0x0000000800cabbf8","execute","lambda$handle$1","one.nio.http.HttpServer","handleRequest","RequestHandler0_handle","ok.dht.test.kovalenko.MyServiceBase","handle","ok.dht.test.kovalenko.LoadBalancer","balance","handleWithReplicas","ok.dht.test.kovalenko.LoadBalancer$$Lambda$210.0x0000000800d853a0","ok.dht.test.kovalenko.Node","proxyRequest","ok.dht.test.kovalenko.Client","put","requestForKey","ok.dht.test.kovalenko.utils.ReplicasUtils$Replicas","toHttpString","java.lang.invoke.MethodHandleNatives","linkCallSite","linkCallSiteImpl","java.lang.invoke.CallSite","makeSite","java.lang.invoke.BootstrapMethodInvoker","invoke","java.lang.invoke.Invokers$Holder","invokeExact_MT","java.lang.invoke.DelegatingMethodHandle$Holder","delegate","java.lang.invoke.DirectMethodHandle$Holder","invokeStatic","java.lang.invoke.StringConcatFactory","makeConcatWithConstants","generateMHInlineCopy","java.lang.invoke.MethodHandles","foldArgumentsWithCombiner","argumentsWithCombiner","java.lang.invoke.BoundMethodHandle$Species_LLL","copyWithExtendL","java.lang.invoke.BoundMethodHandle$Species_LLLL","make","<init>","java.lang.invoke.BoundMethodHandle","java.lang.invoke.MethodHandle","java.lang.invoke.LambdaForm","prepare","compileToBytecode","java.lang.invoke.InvokerBytecodeGenerator","generateCustomizedCode","generateCustomizedCodeBytes","classFilePrologue","jdk.internal.org.objectweb.asm.ClassWriter","visitSource","jdk.internal.org.objectweb.asm.SymbolTable","addConstantUtf8","jdk.internal.org.objectweb.asm.ByteVector","putUTF8","enlarge","byte[]","one.nio.server.SelectorThread","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","one.nio.util.Utf8","read","toAsciiString","java.lang.invoke.LambdaForm$MH.0x0000000800d80000","java.lang.invoke.Invokers","checkCustomized","maybeCustomize","customize","updateForm","java.lang.invoke.MethodHandle$1","apply","addMethod","jdk.internal.org.objectweb.asm.MethodWriter","visitVarInsn","jdk.internal.org.objectweb.asm.Frame","setLocal","int[]","jdk.internal.net.http.HttpClientImpl$SelectorManager","jdk.internal.net.http.HttpClientImpl$SelectorAttachment","events","java.util.stream.ReferencePipeline","filter","java.util.stream.ReferencePipeline$2","jdk.internal.net.http.common.SequentialScheduler$SchedulableTask","jdk.internal.net.http.common.SequentialScheduler$CompleteRestartableTask","jdk.internal.net.http.common.SequentialScheduler$TryEndDeferredCompleter","complete","jdk.internal.net.http.common.SequentialScheduler$LockingRestartableTask","jdk.internal.net.http.Http1AsyncReceiver$$Lambda$318.0x0000000800dab7c8","jdk.internal.net.http.Http1AsyncReceiver","flush","handlePendingDelegate","jdk.internal.net.http.Http1Response$BodyReader","onSubscribe","jdk.internal.net.http.ResponseContent$FixedLengthBodyParser","jdk.internal.net.http.Http1Response$$Lambda$525.0x0000000800e0e440","jdk.internal.net.http.Http1Response","onFinished","jdk.internal.net.http.HttpConnection","closeOrReturnToCache","linkMethodHandleConstant","java.lang.invoke.MethodHandles$Lookup","resolveOrFail","java.lang.invoke.MemberName$Factory","resolve","java.lang.invoke.MemberName","clone","java.lang.Object","sendAsync","jdk.internal.net.http.HttpClientFacade","jdk.internal.net.http.HttpClientImpl","jdk.internal.net.http.MultiExchange","filterChain","jdk.internal.net.http.FilterFactory","getFilterChain","java.lang.Class","getConstructor","jdk.internal.reflect.ReflectionFactory","copyConstructor","java.lang.reflect.ReflectAccess","java.lang.reflect.Constructor","copy","java.util.concurrent.CompletableFuture$AsyncSupply","java.util.concurrent.CompletableFuture","postComplete","java.util.concurrent.CompletableFuture$UniCompose","tryFire","jdk.internal.net.http.MultiExchange$$Lambda$219.0x0000000800d88eb8","lambda$responseAsync0$2","responseAsyncImpl","jdk.internal.net.http.Exchange","responseAsync","responseAsyncImpl0","establishExchange","jdk.internal.net.http.ExchangeImpl","get","jdk.internal.net.http.Http2ClientImpl","getConnectionFor","jdk.internal.net.http.common.MinimalFuture","completedFuture","java.util.ArrayList","iterator","java.util.ArrayList$Itr","one.nio.net.NativeSelector","select","one.nio.net.NativeSelector$2","jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$454.0x0000000800e06358","jdk.internal.net.http.SocketTube$InternalWriteSubscriber","requestMore","jdk.internal.net.http.SocketTube$InternalWriteSubscriber$WriteSubscription","jdk.internal.net.http.Http1Exchange$Http1Publisher$Http1WriteSubscription","request","jdk.internal.net.http.common.SequentialScheduler","runOrSchedule","jdk.internal.net.http.HttpClientImpl$DelegatingExecutor","jdk.internal.net.http.Http1Exchange$Http1Publisher$WriteTask","jdk.internal.net.http.Http1Exchange","getOutgoing","linkToTargetMethod","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","jdk.internal.misc.Unsafe","jdk.internal.net.http.Http1Exchange$$Lambda$491.0x0000000800e088a0","uniHandleStage","uniHandle","jdk.internal.net.http.Exchange$$Lambda$341.0x0000000800dae910","lambda$responseAsyncImpl0$10","checkFor407","jdk.internal.net.http.Exchange$$Lambda$232.0x0000000800d8a4d0","lambda$responseAsyncImpl0$9","sendHeadersAsync","thenCompose","uniComposeStage","jdk.internal.net.http.Http1Exchange$$Lambda$425.0x0000000800dbd458","lambda$sendHeadersAsync$4","jdk.internal.net.http.Http1Request","headers","collectHeaders0","collectHeaders1","java.util.ImmutableCollections$AbstractImmutableList","java.util.ImmutableCollections$ListItr","jdk.internal.net.http.Http1Response$HeadersReader","tryAsyncReceive","jdk.internal.net.http.Http1Response$Receiver","accept","java.util.concurrent.CompletableFuture$UniApply","java.util.concurrent.CompletableFuture$UniCompletion","claim","java.util.concurrent.CompletableFuture$Completion","postFire","jdk.internal.net.http.MultiExchange$$Lambda$220.0x0000000800d89338","lambda$responseAsync0$4","readBodyAsync","readBody","jdk.internal.net.http.Http1Response$$Lambda$520.0x0000000800e0d760","lambda$readBody$3","addTrailingOperation","jdk.internal.net.http.HttpConnection$TrailingOperations","add","whenComplete","uniWhenCompleteStage","newIncompleteFuture","jdk.internal.net.http.Http1Exchange$$Lambda$455.0x0000000800e06788","jdk.internal.net.http.Http1HeaderParser","parse","resumeOrSecondCR","addHeaderFromString","java.lang.String","substring","java.lang.StringLatin1","newString","java.util.Arrays","copyOfRange","java.net.http.HttpHeaders","of","headersOf","java.util.Collections$UnmodifiableMap","forEach","java.util.TreeMap","java.net.http.HttpHeaders$$Lambda$212.0x0000000800d166a0","lambda$headersOf$1","java.util.List","copyOf","java.util.ImmutableCollections","listCopy","java.util.ImmutableCollections$List12","subscribe","jdk.internal.net.http.Http1AsyncReceiver$$Lambda$389.0x0000000800db86a8","completeAsync","java.util.concurrent.CompletableFuture$UniHandle","jdk.internal.net.http.Exchange$$Lambda$429.0x0000000800dbdd58","lambda$responseAsyncImpl0$8","jdk.internal.net.http.Exchange$$Lambda$230.0x0000000800d8a288","sendRequestBody","sendBodyAsync","thenAccept","uniAcceptStage","uniAcceptNow","jdk.internal.net.http.Http1Exchange$$Lambda$469.0x0000000800e02f88","lambda$sendBodyAsync$8","requestMoreBody","jdk.internal.net.http.Http1Exchange$Http1BodySubscriber","jdk.internal.net.http.PullPublisher$Subscription","jdk.internal.net.http.PullPublisher$Subscription$PullTask","jdk.internal.net.http.Http1Request$FixedContentSubscriber","onComplete","appendToOutgoing","java.util.concurrent.ConcurrentLinkedDeque","offerLast","linkLast","newNode","java.util.concurrent.ConcurrentLinkedDeque$Node","java.util.concurrent.ForkJoinWorkerThread","java.util.concurrent.ForkJoinPool","scan","java.util.concurrent.ForkJoinPool$WorkQueue","topLevelExec","java.util.concurrent.ForkJoinTask","doExec","exec","java.util.concurrent.CompletableFuture$UniWhenComplete","java.util.concurrent.CompletableFuture$UniAccept","ok.dht.test.kovalenko.utils.CompletableFutureSubscriber$$Lambda$225.0x0000000800d859e8","ok.dht.test.kovalenko.utils.CompletableFutureSubscriber","lambda$aggregate$3","ok.dht.test.kovalenko.utils.CompletableFutureUtils","checkForResponseSent","finishAggregation","ok.dht.test.kovalenko.utils.CompletableFutureUtils$$Lambda$580.0x0000000800d87050","lambda$finishAggregation$1","sendResponse","writeResponse","one.nio.http.Response","toBytes","one.nio.util.ByteArrayBuilder","resumeOrEndHeaders","jdk.internal.net.http.Http1Exchange$$Lambda$427.0x0000000800dbd6a0","continueRequest","jdk.internal.net.http.RequestPublishers$ByteArrayPublisher","jdk.internal.net.http.PullPublisher","getBytes","encode","encodeASCII","jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$439.0x0000000800dbfa50","lambda$run$3","handleEvent","jdk.internal.net.http.SocketTube$SocketFlowEvent","jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadEvent","signalEvent","jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription","signalReadable","jdk.internal.net.http.SocketTube$SocketFlowTask","jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$285.0x0000000800da5c40","jdk.internal.net.http.SocketTube","readAvailable","jdk.internal.net.http.SocketTube$SliceBufferSource","append","java.nio.HeapByteBuffer","slice","grow","java.lang.Object[]","java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet","java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1","java.util.concurrent.CompletableFuture$UniRelay","one.nio.http.Request","getHeader","trim","jdk.internal.net.http.HttpRequestImpl","timeout","java.util.Optional","replicasFor","responsibleNodeForKey","java.util.HashMap$KeySet","java.util.HashMap$KeyIterator","java.util.TreeSet","java.lang.StringBuilder","toString","checkRequestMore","jdk.internal.net.http.Http1AsyncReceiver$Http1TubeSubscriber","jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadSubscription","resumeReadEvent","jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$450.0x0000000800e05a78","java.net.URI","create","java.net.URI$Parser","parseHierarchical","parseAuthority","parseServer","parseHostname","firstValue","java.util.Collection","stream","spliterator","java.util.AbstractList$RandomAccessSpliterator","hostString","java.lang.invoke.LambdaForm$MH.0x0000000800c0fc00","java.lang.StringConcatHelper","java.lang.AbstractStringBuilder","ensureCapacityInternal","getTask","java.util.concurrent.SynchronousQueue","poll","java.util.concurrent.SynchronousQueue$TransferStack","transfer","snode","java.util.concurrent.SynchronousQueue$TransferStack$SNode","jdk.internal.net.http.Http1AsyncReceiver$Http1AsyncDelegateSubscription","jdk.internal.net.http.AbstractSubscription","jdk.internal.net.http.common.Demand","java.util.concurrent.atomic.AtomicLong","reinvoke_L","simpleConcat","newArray","allocateUninitializedArray","wrapForUpgrade","java.lang.Long","ok.dht.test.kovalenko.utils.CompletableFutureUtils$ExtendedSubscription","jdk.internal.net.http.ExchangeImpl$$Lambda$236.0x0000000800d98000","lambda$get$0","createExchangeImpl","createHttp1Exchange","jdk.internal.net.http.Http1Exchange$Http1Publisher","jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$437.0x0000000800dbf5f0","java.lang.Iterable","java.net.http.HttpHeaders$$Lambda$213.0x0000000800d168d8","lambda$headersOf$0","jdk.internal.net.http.Http1Request$$Lambda$447.0x0000000800e053b8","test","lambda$collectHeaders0$1","java.util.stream.StreamSupport","java.util.stream.ReferencePipeline$Head","java.lang.invoke.LambdaForm$MH.0x0000000800d02000","jdk.internal.net.http.common.HttpHeadersBuilder","setHeader","ok.dht.test.kovalenko.MyServiceBase$$Lambda$229.0x0000000800d86090","lambda$handlePut$2","emptyResponseFor","ok.dht.test.kovalenko.utils.MyHttpResponse","jdk.internal.net.http.AsyncTriggerEvent","jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$293.0x0000000800da6960","handleSubscribeEvent","asReadOnlyBuffer","java.nio.HeapByteBufferR","java.net.http.HttpRequest","newBuilder","jdk.internal.net.http.HttpRequestBuilderImpl","jdk.internal.net.http.ConnectionPool","returnToPool","registerCleanupTrigger","jdk.internal.net.http.ConnectionPool$CleanupTrigger","java.util.function.BiPredicate$$Lambda$444.0x0000000800dc53d0","java.util.function.BiPredicate","lambda$and$0","jdk.internal.net.http.common.Utils$$Lambda$164.0x0000000800d05b90","jdk.internal.net.http.common.Utils","lambda$static$12","java.util.function.Predicate$$Lambda$154.0x0000000800cbf530","java.util.function.Predicate","lambda$negate$1","jdk.internal.net.http.common.Utils$$Lambda$153.0x0000000800d04dc0","lambda$static$5","readResumeStatusLine","addEntryToEmptyMap","java.util.TreeMap$Entry","jdk.internal.net.http.ConnectionPool$ExpiryList","jdk.internal.net.http.ConnectionPool$ExpiryEntry","convert","toMyHttpResponse","firstValueAsLong","ok.dht.test.kovalenko.LoadBalancer$$Lambda$209.0x0000000800d84cd0","lambda$replicasFor$1","java.util.HashMap","putVal","java.util.HashMap$Node","start","java.nio.ByteBuffer","allocate","java.time.Instant","truncatedTo","plusNanos","plus","ofEpochSecond","jdk.internal.net.http.Http1Exchange$DataPair","computeIfAbsent","resize","java.util.HashMap$Node[]","build","responseAsync0","exceptionallyCompose","uniComposeExceptionallyStage","findFirst","java.util.stream.AbstractPipeline","evaluate","java.util.stream.FindOps$FindOp","evaluateSequential","java.util.stream.FindOps$FindSink$OfRef$$Lambda$14.0x80000001d","java.util.stream.FindOps$FindSink$OfRef","jdk.internal.net.http.Http1Response$Http1BodySubscriber","whenCompleteAsync","toLowerCase","addEntry","thenApply","uniApplyStage","uniApplyNow","jdk.internal.net.http.ExchangeImpl$$Lambda$324.0x0000000800dac988","lambda$createExchangeImpl$2","h2Upgrade","setH2Upgrade","aggregate","ok.dht.test.kovalenko.utils.CompletableFutureSubscriber$$Lambda$226.0x0000000800d85c20","java.util.LinkedList","getSettingsString","getClientSettings","getParameter","getIntegerNetProperty","java.security.AccessController","doPrivileged","executePrivileged","jdk.internal.net.http.common.Utils$$Lambda$146.0x0000000800cafc50","lambda$getIntegerNetProperty$13","sun.net.NetProperties","getInteger","java.lang.Integer","valueOf","java.lang.invoke.LambdaForm$DMH.0x0000000800ca0000","java.net.http.HttpRequest$BodyPublishers","ofByteArray","java.util.concurrent.PriorityBlockingQueue","jdk.internal.net.http.ImmutableHttpRequest","ofNullable","retrieveProxy","sun.net.spi.DefaultProxySelector","sun.net.spi.DefaultProxySelector$3","java.util.Collections","unmodifiableMap","toArray","putConnection","getNode","hash","jdk.internal.net.http.ConnectionPool$CacheKey","hashCode","java.net.http.HttpResponse$BodyHandlers$$Lambda$214.0x0000000800d17518","java.net.http.HttpResponse$BodyHandlers","lambda$ofByteArray$12","java.net.http.HttpResponse$BodySubscribers","jdk.internal.net.http.ResponseSubscribers$ByteArraySubscriber","java.lang.invoke.LambdaForm$DMH.0x0000000800d82c00","java.util.TreeMap$EntrySet","java.util.TreeMap$EntryIterator","java.util.concurrent.atomic.AtomicInteger","lockingScheduler","newInstance","newInstanceWithCaller","java.lang.reflect.AccessibleObject","checkAccess","verifyAccess","slowVerifyAccess","java.lang.ref.WeakReference","java.lang.Class[]","jdk.internal.net.http.ResponseContent","java.lang.invoke.LambdaForm$MH.0x0000000800c91800","java.util.stream.LongPipeline","java.util.stream.FindOps$FindSink$OfLong","java.util.OptionalLong","java.lang.invoke.LambdaForm$MH.0x0000000800e11800","java.lang.invoke.LambdaForm$DMH.0x0000000800e10400","getBodyParser","readResumeHeader","java.lang.String[]","jdk.internal.net.http.Http1Exchange$$Lambda$460.0x0000000800e07b68","lambda$sendBodyAsync$7","cancelIfFailed","jdk.internal.net.http.Http1Exchange$$Lambda$465.0x0000000800e02470","header","addHeader","getBuffer","jdk.internal.net.http.PlainHttpConnection$$Lambda$280.0x0000000800da4468","connectFlows","jdk.internal.net.http.SocketTube$InternalReadPublisher","java.util.concurrent.atomic.AtomicReference","jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$303.0x0000000800da86c0","startSubscription","offer","java.util.concurrent.atomic.AtomicBoolean","getConnection","checkOpen","jdk.internal.net.http.Http1Response$$Lambda$544.0x0000000800e155b8","java.util.LinkedList$Node","mapToLong","java.util.stream.ReferencePipeline$5","plusSeconds","handleParsedRequest","ok.dht.test.kovalenko.MyServerBase$$Lambda$203.0x0000000800cab580","lambda$handleRequest$0","java.util.concurrent.AbstractExecutorService","submit","newTaskFor","java.util.concurrent.Executors","callable","jdk.internal.net.http.MultiExchange$$Lambda$433.0x0000000800dbeac0","lambda$responseAsyncImpl$7","handlePending","signalOnSubscribe","registerTimer","parseRequest","java.lang.invoke.LambdaForm$DMH.0x0000000800d8c000","readStatusLineFeed","jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$443.0x0000000800e04aa8","lambda$run$5","jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$438.0x0000000800dbf828","lambda$run$2","resetInterestOps","java.util.HashSet","java.util.Base64$Encoder","encodeToString","ok.dht.test.kovalenko.LoadBalancer$$Lambda$228.0x0000000800d85e68","handlePut","onNext","tryFlushCurrent","writeAvailable","java.lang.reflect.Array","java.nio.ByteBuffer[]","java.lang.invoke.LambdaForm$MH.0x0000000800d82400","exceptionally","uniExceptionallyStage","java.util.concurrent.CompletableFuture$UniExceptionally","withoutPadding","jdk.internal.net.http.Http1Response$$Lambda$386.0x0000000800db18d0","jdk.internal.net.http.Http1Response$$Lambda$562.0x0000000800e17b40","callMappingFunctionWithCheck","jdk.internal.net.http.common.HttpHeadersBuilder$$Lambda$211.0x0000000800d15bf0","lambda$addHeader$0","java.lang.invoke.LambdaForm$MH.0x0000000800c0d000","newArrayWithSuffix","jdk.internal.net.http.Exchange$$Lambda$482.0x0000000800e016d8","entrySet","java.util.concurrent.CompletableFuture$UniComposeExceptionally","jdk.internal.net.http.Http1HeaderParser$$Lambda$502.0x0000000800e0aba0","lambda$addHeaderFromString$0","getAddress","jdk.internal.net.http.HttpRequestImpl$$Lambda$248.0x0000000800d9b8c0","lambda$getAddress$5","java.net.InetSocketAddress","java.net.InetSocketAddress$InetSocketAddressHolder","jdk.internal.net.http.frame.SettingsFrame","toByteArray","jdk.internal.net.http.MultiExchange$$Lambda$569.0x0000000800e1cf98","jdk.internal.net.http.Http1Response$ClientRefCountTracker","jdk.internal.net.http.ResponseTimerEvent","jdk.internal.net.http.Exchange$$Lambda$476.0x0000000800e03cd8","java.util.stream.ForEachOps$ForEachOp$OfRef","java.util.stream.ForEachOps$ForEachOp","wrapAndCopyInto","wrapSink","opWrapSink","java.util.stream.ReferencePipeline$2$1","java.util.stream.FindOps$FindSink$OfLong$$Lambda$511.0x0000000800dc92d8","jdk.internal.net.http.HttpClientImpl$SelectorAttachment$$Lambda$436.0x0000000800dbf3a0","wrap","jdk.internal.net.http.Http1AsyncReceiver$$Lambda$393.0x0000000800db8d50","and","ok.dht.test.kovalenko.utils.CompletableFutureUtils$Subscription","purgeTimeoutsAndReturnNextDeadline","java.util.TreeMap$KeySet","keyIterator","java.util.TreeMap$KeyIterator","lambda$sendRequestBody$7","getResponseAsync","java.util.concurrent.locks.ReentrantLock","jdk.internal.net.http.ResponseSubscribers","getBodyAsync","jdk.internal.net.http.ResponseSubscribers$$Lambda$556.0x0000000800e16e10","lambda$getBodyAsync$3","ok.dht.test.kovalenko.utils.ReplicasUtils","validate","ok.dht.test.kovalenko.utils.ReplicasUtils$ReplicasValidation","purgeExpiredConnectionsAndReturnNextDeadline","purgeUntil","jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$442.0x0000000800e04870","ok.dht.test.kovalenko.utils.HttpUtils$$Lambda$579.0x0000000800d86e28","readHeadersAsync","jdk.internal.net.http.Http1Response$$Lambda$493.0x0000000800e08ac8","startParsingRequestBody","sun.nio.ch.SelectorImpl","lockAndDoSelect","sun.nio.ch.EPollSelectorImpl","doSelect","processEvents","processReadyEvents","findConnection","thenApplyAsync","now","java.time.Clock","currentInstant","jdk.internal.net.http.PlainHttpConnection","cacheKey","jdk.internal.net.http.MultiExchange$$Lambda$221.0x0000000800d89580","descendingIterator","java.util.LinkedList$DescendingIterator","java.util.LinkedList$ListItr","getPath","java.util.concurrent.locks.ReentrantLock$NonfairSync","jdk.internal.reflect.DelegatingConstructorAccessorImpl","jdk.internal.reflect.GeneratedConstructorAccessor8","jdk.internal.net.http.RedirectFilter","jdk.internal.net.http.Http1Response$$Lambda$383.0x0000000800db1228","java.net.InetAddress","getByName","getAllByName","getAllByName0","java.util.concurrent.ConcurrentSkipListSet","java.util.concurrent.ConcurrentSkipListMap$KeySet","java.util.concurrent.ConcurrentSkipListMap$KeyIterator","jdk.internal.net.http.MultiExchange$$Lambda$432.0x0000000800dbe648","lambda$responseAsyncImpl$6","lambda$wrapForUpgrade$11","checkForUpgradeAsync","listOf","jdk.internal.net.http.Http2Connection","keyFor","keyString","java.lang.invoke.LambdaForm$MH.0x0000000800d97400","java.lang.invoke.LambdaForm$MH.0x0000000800d96000","jdk.internal.net.http.MultiExchange$CancelableRef","uniWhenComplete","jdk.internal.net.http.ResponseSubscribers$$Lambda$559.0x0000000800e17498","lambda$getBodyAsync$2","lambda$responseAsync0$3","jdk.internal.net.http.HttpResponseImpl","responseFilters","jdk.internal.net.http.Exchange$$Lambda$335.0x0000000800dae490","lambda$establishExchange$3",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
